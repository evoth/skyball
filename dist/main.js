/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RocketSim_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RocketSim.js */ \"./src/RocketSim.js\");\n/* harmony import */ var _RocketSim_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_RocketSim_js__WEBPACK_IMPORTED_MODULE_0__);\n\nconst RocketSim = await _RocketSim_js__WEBPACK_IMPORTED_MODULE_0___default()();\nconsole.log(RocketSim.BALL_COLLISION_RADIUS_SOCCAR);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/RocketSim.js":
/*!**************************!*\
  !*** ./src/RocketSim.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var __filename = \"src\\\\RocketSim.js\";\nvar __dirname = \"/\";\n\r\nvar Module = (() => {\r\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\r\n  if (true) _scriptDir = _scriptDir || __filename;\r\n  return (\r\nfunction(Module = {})  {\r\n\r\n// include: shell.js\r\n// The Module object: Our interface to the outside world. We import\r\n// and export values on it. There are various ways Module can be used:\r\n// 1. Not defined. We create it here\r\n// 2. A function parameter, function(Module) { ..generated code.. }\r\n// 3. pre-run appended it, var Module = {}; ..generated code..\r\n// 4. External script tag defines var Module.\r\n// We need to check if Module already exists (e.g. case 3 above).\r\n// Substitution will be replaced with actual code on later stage of the build,\r\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n// Note that if you want to run closure, and also to use Module\r\n// after the generated code, you will need to define   var Module = {};\r\n// before the code. Then that object will be used in the code, and you\r\n// can continue to use Module afterwards as well.\r\nvar Module = typeof Module != 'undefined' ? Module : {};\r\n\r\n// Set up the promise that indicates the Module is initialized\r\nvar readyPromiseResolve, readyPromiseReject;\r\nModule['ready'] = new Promise((resolve, reject) => {\r\n  readyPromiseResolve = resolve;\r\n  readyPromiseReject = reject;\r\n});\r\n[\"_main\",\"__embind_initialize_bindings\",\"_fflush\",\"onRuntimeInitialized\"].forEach((prop) => {\r\n  if (!Object.getOwnPropertyDescriptor(Module['ready'], prop)) {\r\n    Object.defineProperty(Module['ready'], prop, {\r\n      get: () => abort('You are getting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\r\n      set: () => abort('You are setting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\r\n    });\r\n  }\r\n});\r\n\r\n// --pre-jses are emitted after the Module integration code, so that they can\r\n// refer to Module (if they choose; they can also define Module)\r\n\r\n  if (!Module.expectedDataFileDownloads) {\r\n    Module.expectedDataFileDownloads = 0;\r\n  }\r\n\r\n  Module.expectedDataFileDownloads++;\r\n  (function() {\r\n    // Do not attempt to redownload the virtual filesystem data when in a pthread or a Wasm Worker context.\r\n    if (Module['ENVIRONMENT_IS_PTHREAD'] || Module['$ww']) return;\r\n    var loadPackage = function(metadata) {\r\n\r\n      var PACKAGE_PATH = '';\r\n      if (typeof window === 'object') {\r\n        PACKAGE_PATH = window['encodeURIComponent'](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf('/')) + '/');\r\n      } else if (typeof process === 'undefined' && typeof location !== 'undefined') {\r\n        // web worker\r\n        PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf('/')) + '/');\r\n      }\r\n      var PACKAGE_NAME = 'src/RocketSim.data';\r\n      var REMOTE_PACKAGE_BASE = 'RocketSim.data';\r\n      if (typeof Module['locateFilePackage'] === 'function' && !Module['locateFile']) {\r\n        Module['locateFile'] = Module['locateFilePackage'];\r\n        err('warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)');\r\n      }\r\n      var REMOTE_PACKAGE_NAME = Module['locateFile'] ? Module['locateFile'](REMOTE_PACKAGE_BASE, '') : REMOTE_PACKAGE_BASE;\r\nvar REMOTE_PACKAGE_SIZE = metadata['remote_package_size'];\r\n\r\n      function fetchRemotePackage(packageName, packageSize, callback, errback) {\r\n        if (typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string') {\r\n          (__webpack_require__(/*! fs */ \"fs\").readFile)(packageName, function(err, contents) {\r\n            if (err) {\r\n              errback(err);\r\n            } else {\r\n              callback(contents.buffer);\r\n            }\r\n          });\r\n          return;\r\n        }\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', packageName, true);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.onprogress = function(event) {\r\n          var url = packageName;\r\n          var size = packageSize;\r\n          if (event.total) size = event.total;\r\n          if (event.loaded) {\r\n            if (!xhr.addedTotal) {\r\n              xhr.addedTotal = true;\r\n              if (!Module.dataFileDownloads) Module.dataFileDownloads = {};\r\n              Module.dataFileDownloads[url] = {\r\n                loaded: event.loaded,\r\n                total: size\r\n              };\r\n            } else {\r\n              Module.dataFileDownloads[url].loaded = event.loaded;\r\n            }\r\n            var total = 0;\r\n            var loaded = 0;\r\n            var num = 0;\r\n            for (var download in Module.dataFileDownloads) {\r\n            var data = Module.dataFileDownloads[download];\r\n              total += data.total;\r\n              loaded += data.loaded;\r\n              num++;\r\n            }\r\n            total = Math.ceil(total * Module.expectedDataFileDownloads/num);\r\n            if (Module['setStatus']) Module['setStatus'](`Downloading data... (${loaded}/${total})`);\r\n          } else if (!Module.dataFileDownloads) {\r\n            if (Module['setStatus']) Module['setStatus']('Downloading data...');\r\n          }\r\n        };\r\n        xhr.onerror = function(event) {\r\n          throw new Error(\"NetworkError for: \" + packageName);\r\n        }\r\n        xhr.onload = function(event) {\r\n          if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\r\n            var packageData = xhr.response;\r\n            callback(packageData);\r\n          } else {\r\n            throw new Error(xhr.statusText + \" : \" + xhr.responseURL);\r\n          }\r\n        };\r\n        xhr.send(null);\r\n      };\r\n\r\n      function handleError(error) {\r\n        console.error('package error:', error);\r\n      };\r\n\r\n      var fetchedCallback = null;\r\n      var fetched = Module['getPreloadedPackage'] ? Module['getPreloadedPackage'](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null;\r\n\r\n      if (!fetched) fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, function(data) {\r\n        if (fetchedCallback) {\r\n          fetchedCallback(data);\r\n          fetchedCallback = null;\r\n        } else {\r\n          fetched = data;\r\n        }\r\n      }, handleError);\r\n\r\n    function runWithFS() {\r\n\r\n      function assert(check, msg) {\r\n        if (!check) throw msg + new Error().stack;\r\n      }\r\nModule['FS_createPath'](\"/\", \"collision_meshes\", true, true);\r\nModule['FS_createPath'](\"/collision_meshes\", \"soccar\", true, true);\r\n\r\n      /** @constructor */\r\n      function DataRequest(start, end, audio) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.audio = audio;\r\n      }\r\n      DataRequest.prototype = {\r\n        requests: {},\r\n        open: function(mode, name) {\r\n          this.name = name;\r\n          this.requests[name] = this;\r\n          Module['addRunDependency'](`fp ${this.name}`);\r\n        },\r\n        send: function() {},\r\n        onload: function() {\r\n          var byteArray = this.byteArray.subarray(this.start, this.end);\r\n          this.finish(byteArray);\r\n        },\r\n        finish: function(byteArray) {\r\n          var that = this;\r\n          // canOwn this data in the filesystem, it is a slide into the heap that will never change\r\n          Module['FS_createDataFile'](this.name, null, byteArray, true, true, true);\r\n          Module['removeRunDependency'](`fp ${that.name}`);\r\n          this.requests[this.name] = null;\r\n        }\r\n      };\r\n\r\n      var files = metadata['files'];\r\n      for (var i = 0; i < files.length; ++i) {\r\n        new DataRequest(files[i]['start'], files[i]['end'], files[i]['audio'] || 0).open('GET', files[i]['filename']);\r\n      }\r\n\r\n      function processPackageData(arrayBuffer) {\r\n        assert(arrayBuffer, 'Loading data file failed.');\r\n        assert(arrayBuffer.constructor.name === ArrayBuffer.name, 'bad input to processPackageData');\r\n        var byteArray = new Uint8Array(arrayBuffer);\r\n        var curr;\r\n        // Reuse the bytearray from the XHR as the source for file reads.\r\n          DataRequest.prototype.byteArray = byteArray;\r\n          var files = metadata['files'];\r\n          for (var i = 0; i < files.length; ++i) {\r\n            DataRequest.prototype.requests[files[i].filename].onload();\r\n          }          Module['removeRunDependency']('datafile_src/RocketSim.data');\r\n\r\n      };\r\n      Module['addRunDependency']('datafile_src/RocketSim.data');\r\n\r\n      if (!Module.preloadResults) Module.preloadResults = {};\r\n\r\n      Module.preloadResults[PACKAGE_NAME] = {fromCache: false};\r\n      if (fetched) {\r\n        processPackageData(fetched);\r\n        fetched = null;\r\n      } else {\r\n        fetchedCallback = processPackageData;\r\n      }\r\n\r\n    }\r\n    if (Module['calledRun']) {\r\n      runWithFS();\r\n    } else {\r\n      if (!Module['preRun']) Module['preRun'] = [];\r\n      Module[\"preRun\"].push(runWithFS); // FS is not initialized yet, wait for it\r\n    }\r\n\r\n    }\r\n    loadPackage({\"files\": [{\"filename\": \"/collision_meshes/soccar/mesh_0.cmf\", \"start\": 0, \"end\": 16364}, {\"filename\": \"/collision_meshes/soccar/mesh_1.cmf\", \"start\": 16364, \"end\": 32728}, {\"filename\": \"/collision_meshes/soccar/mesh_10.cmf\", \"start\": 32728, \"end\": 35208}, {\"filename\": \"/collision_meshes/soccar/mesh_11.cmf\", \"start\": 35208, \"end\": 37688}, {\"filename\": \"/collision_meshes/soccar/mesh_12.cmf\", \"start\": 37688, \"end\": 40168}, {\"filename\": \"/collision_meshes/soccar/mesh_13.cmf\", \"start\": 40168, \"end\": 42648}, {\"filename\": \"/collision_meshes/soccar/mesh_14.cmf\", \"start\": 42648, \"end\": 43064}, {\"filename\": \"/collision_meshes/soccar/mesh_15.cmf\", \"start\": 43064, \"end\": 43480}, {\"filename\": \"/collision_meshes/soccar/mesh_2.cmf\", \"start\": 43480, \"end\": 59844}, {\"filename\": \"/collision_meshes/soccar/mesh_3.cmf\", \"start\": 59844, \"end\": 76208}, {\"filename\": \"/collision_meshes/soccar/mesh_4.cmf\", \"start\": 76208, \"end\": 94444}, {\"filename\": \"/collision_meshes/soccar/mesh_5.cmf\", \"start\": 94444, \"end\": 112680}, {\"filename\": \"/collision_meshes/soccar/mesh_6.cmf\", \"start\": 112680, \"end\": 130916}, {\"filename\": \"/collision_meshes/soccar/mesh_7.cmf\", \"start\": 130916, \"end\": 149152}, {\"filename\": \"/collision_meshes/soccar/mesh_8.cmf\", \"start\": 149152, \"end\": 149568}, {\"filename\": \"/collision_meshes/soccar/mesh_9.cmf\", \"start\": 149568, \"end\": 149984}], \"remote_package_size\": 149984});\r\n\r\n  })();\r\n\r\n\r\n    // All the pre-js content up to here must remain later on, we need to run\r\n    // it.\r\n    if (Module['ENVIRONMENT_IS_PTHREAD'] || Module['$ww']) Module['preRun'] = [];\r\n    var necessaryPreJSTasks = Module['preRun'].slice();\r\n  \r\n    if (!Module['preRun']) throw 'Module.preRun should exist because file support used it; did a pre-js delete it?';\r\n    necessaryPreJSTasks.forEach(function(task) {\r\n      if (Module['preRun'].indexOf(task) < 0) throw 'All preRun tasks that exist before user pre-js code should remain after; did you replace Module or modify Module.preRun?';\r\n    });\r\n  \r\n\r\n// Sometimes an existing Module object exists with properties\r\n// meant to overwrite the default module functionality. Here\r\n// we collect those properties and reapply _after_ we configure\r\n// the current environment's defaults to avoid having to be so\r\n// defensive during initialization.\r\nvar moduleOverrides = Object.assign({}, Module);\r\n\r\nvar arguments_ = [];\r\nvar thisProgram = './this.program';\r\nvar quit_ = (status, toThrow) => {\r\n  throw toThrow;\r\n};\r\n\r\n// Determine the runtime environment we are in. You can customize this by\r\n// setting the ENVIRONMENT setting at compile time (see settings.js).\r\n\r\n// Attempt to auto-detect the environment\r\nvar ENVIRONMENT_IS_WEB = typeof window == 'object';\r\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\r\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\r\n// also a web environment.\r\nvar ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\r\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n\r\nif (Module['ENVIRONMENT']) {\r\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\r\n}\r\n\r\n// `/` should be present at the end if `scriptDirectory` is not empty\r\nvar scriptDirectory = '';\r\nfunction locateFile(path) {\r\n  if (Module['locateFile']) {\r\n    return Module['locateFile'](path, scriptDirectory);\r\n  }\r\n  return scriptDirectory + path;\r\n}\r\n\r\n// Hooks that are implemented differently in different runtime environments.\r\nvar read_,\r\n    readAsync,\r\n    readBinary,\r\n    setWindowTitle;\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  if (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n  var nodeVersion = process.versions.node;\r\n  var numericVersion = nodeVersion.split('.').slice(0, 3);\r\n  numericVersion = (numericVersion[0] * 10000) + (numericVersion[1] * 100) + (numericVersion[2].split('-')[0] * 1);\r\n  var minVersion = 101900;\r\n  if (numericVersion < 101900) {\r\n    throw new Error('This emscripten-generated code requires node v10.19.19.0 (detected v' + nodeVersion + ')');\r\n  }\r\n\r\n  // `require()` is no-op in an ESM module, use `createRequire()` to construct\r\n  // the require()` function.  This is only necessary for multi-environment\r\n  // builds, `-sENVIRONMENT=node` emits a static import declaration instead.\r\n  // TODO: Swap all `require()`'s with `import()`'s?\r\n  // These modules will usually be used on Node.js. Load them eagerly to avoid\r\n  // the complexity of lazy-loading.\r\n  var fs = __webpack_require__(/*! fs */ \"fs\");\r\n  var nodePath = __webpack_require__(/*! path */ \"path\");\r\n\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n    scriptDirectory = nodePath.dirname(scriptDirectory) + '/';\r\n  } else {\r\n    scriptDirectory = __dirname + '/';\r\n  }\r\n\r\n// include: node_shell_read.js\r\nread_ = (filename, binary) => {\r\n  // We need to re-wrap `file://` strings to URLs. Normalizing isn't\r\n  // necessary in that case, the path should already be absolute.\r\n  filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\r\n  return fs.readFileSync(filename, binary ? undefined : 'utf8');\r\n};\r\n\r\nreadBinary = (filename) => {\r\n  var ret = read_(filename, true);\r\n  if (!ret.buffer) {\r\n    ret = new Uint8Array(ret);\r\n  }\r\n  assert(ret.buffer);\r\n  return ret;\r\n};\r\n\r\nreadAsync = (filename, onload, onerror, binary = true) => {\r\n  // See the comment in the `read_` function.\r\n  filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\r\n  fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {\r\n    if (err) onerror(err);\r\n    else onload(binary ? data.buffer : data);\r\n  });\r\n};\r\n\r\n// end include: node_shell_read.js\r\n  if (!Module['thisProgram'] && process.argv.length > 1) {\r\n    thisProgram = process.argv[1].replace(/\\\\/g, '/');\r\n  }\r\n\r\n  arguments_ = process.argv.slice(2);\r\n\r\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\r\n\r\n  quit_ = (status, toThrow) => {\r\n    process.exitCode = status;\r\n    throw toThrow;\r\n  };\r\n\r\n  Module['inspect'] = () => '[Emscripten Module object]';\r\n\r\n} else\r\nif (ENVIRONMENT_IS_SHELL) {\r\n\r\n  if ((typeof process == 'object' && \"function\" === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n  if (typeof read != 'undefined') {\r\n    read_ = (f) => {\r\n      return read(f);\r\n    };\r\n  }\r\n\r\n  readBinary = (f) => {\r\n    let data;\r\n    if (typeof readbuffer == 'function') {\r\n      return new Uint8Array(readbuffer(f));\r\n    }\r\n    data = read(f, 'binary');\r\n    assert(typeof data == 'object');\r\n    return data;\r\n  };\r\n\r\n  readAsync = (f, onload, onerror) => {\r\n    setTimeout(() => onload(readBinary(f)), 0);\r\n  };\r\n\r\n  if (typeof clearTimeout == 'undefined') {\r\n    globalThis.clearTimeout = (id) => {};\r\n  }\r\n\r\n  if (typeof scriptArgs != 'undefined') {\r\n    arguments_ = scriptArgs;\r\n  } else if (typeof arguments != 'undefined') {\r\n    arguments_ = arguments;\r\n  }\r\n\r\n  if (typeof quit == 'function') {\r\n    quit_ = (status, toThrow) => {\r\n      // Unlike node which has process.exitCode, d8 has no such mechanism. So we\r\n      // have no way to set the exit code and then let the program exit with\r\n      // that code when it naturally stops running (say, when all setTimeouts\r\n      // have completed). For that reason, we must call `quit` - the only way to\r\n      // set the exit code - but quit also halts immediately.  To increase\r\n      // consistency with node (and the web) we schedule the actual quit call\r\n      // using a setTimeout to give the current stack and any exception handlers\r\n      // a chance to run.  This enables features such as addOnPostRun (which\r\n      // expected to be able to run code after main returns).\r\n      setTimeout(() => {\r\n        if (!(toThrow instanceof ExitStatus)) {\r\n          let toLog = toThrow;\r\n          if (toThrow && typeof toThrow == 'object' && toThrow.stack) {\r\n            toLog = [toThrow, toThrow.stack];\r\n          }\r\n          err(`exiting due to exception: ${toLog}`);\r\n        }\r\n        quit(status);\r\n      });\r\n      throw toThrow;\r\n    };\r\n  }\r\n\r\n  if (typeof print != 'undefined') {\r\n    // Prefer to use print/printErr where they exist, as they usually work better.\r\n    if (typeof console == 'undefined') console = /** @type{!Console} */({});\r\n    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);\r\n    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);\r\n  }\r\n\r\n} else\r\n\r\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\r\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\r\n// ENVIRONMENT_IS_NODE.\r\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\r\n    scriptDirectory = self.location.href;\r\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\r\n    scriptDirectory = document.currentScript.src;\r\n  }\r\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\r\n  // is gone, so we saved it, and we use it here instead of any other info.\r\n  if (_scriptDir) {\r\n    scriptDirectory = _scriptDir;\r\n  }\r\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\r\n  // otherwise, slice off the final part of the url to find the script directory.\r\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\r\n  // and scriptDirectory will correctly be replaced with an empty string.\r\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\r\n  // they are removed because they could contain a slash.\r\n  if (scriptDirectory.indexOf('blob:') !== 0) {\r\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf('/')+1);\r\n  } else {\r\n    scriptDirectory = '';\r\n  }\r\n\r\n  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n  // Differentiate the Web Worker from the Node Worker case, as reading must\r\n  // be done differently.\r\n  {\r\n// include: web_or_worker_shell_read.js\r\nread_ = (url) => {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open('GET', url, false);\r\n      xhr.send(null);\r\n      return xhr.responseText;\r\n  }\r\n\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n    readBinary = (url) => {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, false);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.send(null);\r\n        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\r\n    };\r\n  }\r\n\r\n  readAsync = (url, onload, onerror) => {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, true);\r\n    xhr.responseType = 'arraybuffer';\r\n    xhr.onload = () => {\r\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\r\n        onload(xhr.response);\r\n        return;\r\n      }\r\n      onerror();\r\n    };\r\n    xhr.onerror = onerror;\r\n    xhr.send(null);\r\n  }\r\n\r\n// end include: web_or_worker_shell_read.js\r\n  }\r\n\r\n  setWindowTitle = (title) => document.title = title;\r\n} else\r\n{\r\n  throw new Error('environment detection error');\r\n}\r\n\r\nvar out = Module['print'] || console.log.bind(console);\r\nvar err = Module['printErr'] || console.error.bind(console);\r\n\r\n// Merge back in the overrides\r\nObject.assign(Module, moduleOverrides);\r\n// Free the object hierarchy contained in the overrides, this lets the GC\r\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\r\nmoduleOverrides = null;\r\ncheckIncomingModuleAPI();\r\n\r\n// Emit code to handle expected values on the Module object. This applies Module.x\r\n// to the proper local x. This has two benefits: first, we only emit it if it is\r\n// expected to arrive, and second, by using a local everywhere else that can be\r\n// minified.\r\n\r\nif (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');\r\n\r\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');\r\n\r\nif (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');\r\n\r\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\r\n// Assertions on removed incoming Module JS APIs.\r\nassert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');\r\nassert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\r\nassert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\r\nassert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\r\nassert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\r\nlegacyModuleProp('read', 'read_');\r\nlegacyModuleProp('readAsync', 'readAsync');\r\nlegacyModuleProp('readBinary', 'readBinary');\r\nlegacyModuleProp('setWindowTitle', 'setWindowTitle');\r\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\r\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\r\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\r\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\r\n\r\nassert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\");\r\n\r\n\r\n// end include: shell.js\r\n// include: preamble.js\r\n// === Preamble library stuff ===\r\n\r\n// Documentation for the public APIs defined in this file must be updated in:\r\n//    site/source/docs/api_reference/preamble.js.rst\r\n// A prebuilt local version of the documentation is available at:\r\n//    site/build/text/docs/api_reference/preamble.js.txt\r\n// You can also build docs locally as HTML or other formats in site/\r\n// An online HTML version (which may be of a different version of Emscripten)\r\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\n\r\nvar wasmBinary;\r\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');\r\nvar noExitRuntime = Module['noExitRuntime'] || true;legacyModuleProp('noExitRuntime', 'noExitRuntime');\r\n\r\nif (typeof WebAssembly != 'object') {\r\n  abort('no native wasm support detected');\r\n}\r\n\r\n// Wasm globals\r\n\r\nvar wasmMemory;\r\n\r\n//========================================\r\n// Runtime essentials\r\n//========================================\r\n\r\n// whether we are quitting the application. no code should run after this.\r\n// set in exit() and abort()\r\nvar ABORT = false;\r\n\r\n// set by exit() and abort().  Passed to 'onExit' handler.\r\n// NOTE: This is also used as the process return code code in shell environments\r\n// but only when noExitRuntime is false.\r\nvar EXITSTATUS;\r\n\r\n/** @type {function(*, string=)} */\r\nfunction assert(condition, text) {\r\n  if (!condition) {\r\n    abort('Assertion failed' + (text ? ': ' + text : ''));\r\n  }\r\n}\r\n\r\n// We used to include malloc/free by default in the past. Show a helpful error in\r\n// builds with assertions.\r\n\r\n// Memory management\r\n\r\nvar HEAP,\r\n/** @type {!Int8Array} */\r\n  HEAP8,\r\n/** @type {!Uint8Array} */\r\n  HEAPU8,\r\n/** @type {!Int16Array} */\r\n  HEAP16,\r\n/** @type {!Uint16Array} */\r\n  HEAPU16,\r\n/** @type {!Int32Array} */\r\n  HEAP32,\r\n/** @type {!Uint32Array} */\r\n  HEAPU32,\r\n/** @type {!Float32Array} */\r\n  HEAPF32,\r\n/* BigInt64Array type is not correctly defined in closure\r\n/** not-@type {!BigInt64Array} */\r\n  HEAP64,\r\n/* BigUInt64Array type is not correctly defined in closure\r\n/** not-t@type {!BigUint64Array} */\r\n  HEAPU64,\r\n/** @type {!Float64Array} */\r\n  HEAPF64;\r\n\r\nfunction updateMemoryViews() {\r\n  var b = wasmMemory.buffer;\r\n  Module['HEAP8'] = HEAP8 = new Int8Array(b);\r\n  Module['HEAP16'] = HEAP16 = new Int16Array(b);\r\n  Module['HEAP32'] = HEAP32 = new Int32Array(b);\r\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\r\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\r\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\r\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\r\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\r\n  Module['HEAP64'] = HEAP64 = new BigInt64Array(b);\r\n  Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);\r\n}\r\n\r\nassert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time')\r\n\r\nassert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,\r\n       'JS engine does not provide full typed array support');\r\n\r\n// If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\r\nassert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\r\nassert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\r\n\r\n// include: runtime_init_table.js\r\n// In regular non-RELOCATABLE mode the table is exported\r\n// from the wasm module and this will be assigned once\r\n// the exports are available.\r\nvar wasmTable;\r\n\r\n// end include: runtime_init_table.js\r\n// include: runtime_stack_check.js\r\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\r\nfunction writeStackCookie() {\r\n  var max = _emscripten_stack_get_end();\r\n  assert((max & 3) == 0);\r\n  // If the stack ends at address zero we write our cookies 4 bytes into the\r\n  // stack.  This prevents interference with SAFE_HEAP and ASAN which also\r\n  // monitor writes to address zero.\r\n  if (max == 0) {\r\n    max += 4;\r\n  }\r\n  // The stack grow downwards towards _emscripten_stack_get_end.\r\n  // We write cookies to the final two words in the stack and detect if they are\r\n  // ever overwritten.\r\n  HEAPU32[((max)>>2)] = 0x02135467;\r\n  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;\r\n  // Also test the global address 0 for integrity.\r\n  HEAPU32[((0)>>2)] = 1668509029;\r\n}\r\n\r\nfunction checkStackCookie() {\r\n  if (ABORT) return;\r\n  var max = _emscripten_stack_get_end();\r\n  // See writeStackCookie().\r\n  if (max == 0) {\r\n    max += 4;\r\n  }\r\n  var cookie1 = HEAPU32[((max)>>2)];\r\n  var cookie2 = HEAPU32[(((max)+(4))>>2)];\r\n  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\r\n    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\r\n  }\r\n  // Also test the global address 0 for integrity.\r\n  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {\r\n    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\r\n  }\r\n}\r\n\r\n// end include: runtime_stack_check.js\r\n// include: runtime_assertions.js\r\n// Endianness check\r\n(function() {\r\n  var h16 = new Int16Array(1);\r\n  var h8 = new Int8Array(h16.buffer);\r\n  h16[0] = 0x6373;\r\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\r\n})();\r\n\r\n// end include: runtime_assertions.js\r\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\r\nvar __ATINIT__    = []; // functions called during startup\r\nvar __ATEXIT__    = []; // functions called during shutdown\r\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\r\n\r\nvar runtimeInitialized = false;\r\n\r\nvar runtimeKeepaliveCounter = 0;\r\n\r\nfunction keepRuntimeAlive() {\r\n  return noExitRuntime || runtimeKeepaliveCounter > 0;\r\n}\r\n\r\nfunction preRun() {\r\n  if (Module['preRun']) {\r\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\r\n    while (Module['preRun'].length) {\r\n      addOnPreRun(Module['preRun'].shift());\r\n    }\r\n  }\r\n  callRuntimeCallbacks(__ATPRERUN__);\r\n}\r\n\r\nfunction initRuntime() {\r\n  assert(!runtimeInitialized);\r\n  runtimeInitialized = true;\r\n\r\n  checkStackCookie();\r\n\r\n  \r\nif (!Module[\"noFSInit\"] && !FS.init.initialized)\r\n  FS.init();\r\nFS.ignorePermissions = false;\r\n\r\nTTY.init();\r\n  callRuntimeCallbacks(__ATINIT__);\r\n}\r\n\r\nfunction postRun() {\r\n  checkStackCookie();\r\n\r\n  if (Module['postRun']) {\r\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\r\n    while (Module['postRun'].length) {\r\n      addOnPostRun(Module['postRun'].shift());\r\n    }\r\n  }\r\n\r\n  callRuntimeCallbacks(__ATPOSTRUN__);\r\n}\r\n\r\nfunction addOnPreRun(cb) {\r\n  __ATPRERUN__.unshift(cb);\r\n}\r\n\r\nfunction addOnInit(cb) {\r\n  __ATINIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnExit(cb) {\r\n}\r\n\r\nfunction addOnPostRun(cb) {\r\n  __ATPOSTRUN__.unshift(cb);\r\n}\r\n\r\n// include: runtime_math.js\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\r\n\r\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\n\r\n// end include: runtime_math.js\r\n// A counter of dependencies for calling run(). If we need to\r\n// do asynchronous work before running, increment this and\r\n// decrement it. Incrementing must happen in a place like\r\n// Module.preRun (used by emcc to add file preloading).\r\n// Note that you can add dependencies in preRun, even though\r\n// it happens right before run - run will be postponed until\r\n// the dependencies are met.\r\nvar runDependencies = 0;\r\nvar runDependencyWatcher = null;\r\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\r\nvar runDependencyTracking = {};\r\n\r\nfunction getUniqueRunDependency(id) {\r\n  var orig = id;\r\n  while (1) {\r\n    if (!runDependencyTracking[id]) return id;\r\n    id = orig + Math.random();\r\n  }\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n  runDependencies++;\r\n\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n\r\n  if (id) {\r\n    assert(!runDependencyTracking[id]);\r\n    runDependencyTracking[id] = 1;\r\n    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\r\n      // Check for missing dependencies every few seconds\r\n      runDependencyWatcher = setInterval(() => {\r\n        if (ABORT) {\r\n          clearInterval(runDependencyWatcher);\r\n          runDependencyWatcher = null;\r\n          return;\r\n        }\r\n        var shown = false;\r\n        for (var dep in runDependencyTracking) {\r\n          if (!shown) {\r\n            shown = true;\r\n            err('still waiting on run dependencies:');\r\n          }\r\n          err('dependency: ' + dep);\r\n        }\r\n        if (shown) {\r\n          err('(end of list)');\r\n        }\r\n      }, 10000);\r\n    }\r\n  } else {\r\n    err('warning: run dependency added without ID');\r\n  }\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n  runDependencies--;\r\n\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n\r\n  if (id) {\r\n    assert(runDependencyTracking[id]);\r\n    delete runDependencyTracking[id];\r\n  } else {\r\n    err('warning: run dependency removed without ID');\r\n  }\r\n  if (runDependencies == 0) {\r\n    if (runDependencyWatcher !== null) {\r\n      clearInterval(runDependencyWatcher);\r\n      runDependencyWatcher = null;\r\n    }\r\n    if (dependenciesFulfilled) {\r\n      var callback = dependenciesFulfilled;\r\n      dependenciesFulfilled = null;\r\n      callback(); // can add another dependenciesFulfilled\r\n    }\r\n  }\r\n}\r\n\r\n/** @param {string|number=} what */\r\nfunction abort(what) {\r\n  if (Module['onAbort']) {\r\n    Module['onAbort'](what);\r\n  }\r\n\r\n  what = 'Aborted(' + what + ')';\r\n  // TODO(sbc): Should we remove printing and leave it up to whoever\r\n  // catches the exception?\r\n  err(what);\r\n\r\n  ABORT = true;\r\n  EXITSTATUS = 1;\r\n\r\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\r\n  // exception, which means we'd run destructors on it. We need the error to\r\n  // simply make the program stop.\r\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\r\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\r\n  // a trap or not based on a hidden field within the object. So at the moment\r\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\r\n  // allows this in the wasm spec.\r\n\r\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\r\n  // defintion for WebAssembly.RuntimeError claims it takes no arguments even\r\n  // though it can.\r\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\r\n  /** @suppress {checkTypes} */\r\n  var e = new WebAssembly.RuntimeError(what);\r\n\r\n  readyPromiseReject(e);\r\n  // Throw the error whether or not MODULARIZE is set because abort is used\r\n  // in code paths apart from instantiation where an exception is expected\r\n  // to be thrown when abort is called.\r\n  throw e;\r\n}\r\n\r\n// include: memoryprofiler.js\r\n// end include: memoryprofiler.js\r\n// include: URIUtils.js\r\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\r\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\r\n\r\n// Indicates whether filename is a base64 data URI.\r\nfunction isDataURI(filename) {\r\n  // Prefix of data URIs emitted by SINGLE_FILE and related options.\r\n  return filename.startsWith(dataURIPrefix);\r\n}\r\n\r\n// Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\nfunction isFileURI(filename) {\r\n  return filename.startsWith('file://');\r\n}\r\n\r\n// end include: URIUtils.js\r\n/** @param {boolean=} fixedasm */\r\nfunction createExportWrapper(name, fixedasm) {\r\n  return function() {\r\n    var displayName = name;\r\n    var asm = fixedasm;\r\n    if (!fixedasm) {\r\n      asm = Module['asm'];\r\n    }\r\n    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');\r\n    if (!asm[name]) {\r\n      assert(asm[name], 'exported native function `' + displayName + '` not found');\r\n    }\r\n    return asm[name].apply(null, arguments);\r\n  };\r\n}\r\n\r\n// include: runtime_exceptions.js\r\n// end include: runtime_exceptions.js\r\nvar wasmBinaryFile;\r\n  wasmBinaryFile = 'RocketSim.wasm';\r\n  if (!isDataURI(wasmBinaryFile)) {\r\n    wasmBinaryFile = locateFile(wasmBinaryFile);\r\n  }\r\n\r\nfunction getBinary(file) {\r\n  try {\r\n    if (file == wasmBinaryFile && wasmBinary) {\r\n      return new Uint8Array(wasmBinary);\r\n    }\r\n    if (readBinary) {\r\n      return readBinary(file);\r\n    }\r\n    throw \"both async and sync fetching of the wasm failed\";\r\n  }\r\n  catch (err) {\r\n    abort(err);\r\n  }\r\n}\r\n\r\nfunction getBinaryPromise(binaryFile) {\r\n  // If we don't have the binary yet, try to load it asynchronously.\r\n  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\r\n  // See https://github.com/github/fetch/pull/92#issuecomment-140665932\r\n  // Cordova or Electron apps are typically loaded from a file:// url.\r\n  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\r\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\r\n    if (typeof fetch == 'function'\r\n      && !isFileURI(binaryFile)\r\n    ) {\r\n      return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\r\n        if (!response['ok']) {\r\n          throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\r\n        }\r\n        return response['arrayBuffer']();\r\n      }).catch(() => getBinary(binaryFile));\r\n    }\r\n    else {\r\n      if (readAsync) {\r\n        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)\r\n        return new Promise((resolve, reject) => {\r\n          readAsync(binaryFile, (response) => resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))), reject)\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // Otherwise, getBinary should be able to get it synchronously\r\n  return Promise.resolve().then(() => getBinary(binaryFile));\r\n}\r\n\r\nfunction instantiateArrayBuffer(binaryFile, imports, receiver) {\r\n  return getBinaryPromise(binaryFile).then((binary) => {\r\n    return WebAssembly.instantiate(binary, imports);\r\n  }).then((instance) => {\r\n    return instance;\r\n  }).then(receiver, (reason) => {\r\n    err('failed to asynchronously prepare wasm: ' + reason);\r\n\r\n    // Warn on some common problems.\r\n    if (isFileURI(wasmBinaryFile)) {\r\n      err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');\r\n    }\r\n    abort(reason);\r\n  });\r\n}\r\n\r\nfunction instantiateAsync(binary, binaryFile, imports, callback) {\r\n  if (!binary &&\r\n      typeof WebAssembly.instantiateStreaming == 'function' &&\r\n      !isDataURI(binaryFile) &&\r\n      // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\r\n      !isFileURI(binaryFile) &&\r\n      // Avoid instantiateStreaming() on Node.js environment for now, as while\r\n      // Node.js v18.1.0 implements it, it does not have a full fetch()\r\n      // implementation yet.\r\n      //\r\n      // Reference:\r\n      //   https://github.com/emscripten-core/emscripten/pull/16917\r\n      !ENVIRONMENT_IS_NODE &&\r\n      typeof fetch == 'function') {\r\n    return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\r\n      // Suppress closure warning here since the upstream definition for\r\n      // instantiateStreaming only allows Promise<Repsponse> rather than\r\n      // an actual Response.\r\n      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\r\n      /** @suppress {checkTypes} */\r\n      var result = WebAssembly.instantiateStreaming(response, imports);\r\n\r\n      return result.then(\r\n        callback,\r\n        function(reason) {\r\n          // We expect the most common failure cause to be a bad MIME type for the binary,\r\n          // in which case falling back to ArrayBuffer instantiation should work.\r\n          err('wasm streaming compile failed: ' + reason);\r\n          err('falling back to ArrayBuffer instantiation');\r\n          return instantiateArrayBuffer(binaryFile, imports, callback);\r\n        });\r\n    });\r\n  } else {\r\n    return instantiateArrayBuffer(binaryFile, imports, callback);\r\n  }\r\n}\r\n\r\n// Create the wasm instance.\r\n// Receives the wasm imports, returns the exports.\r\nfunction createWasm() {\r\n  // prepare imports\r\n  var info = {\r\n    'env': wasmImports,\r\n    'wasi_snapshot_preview1': wasmImports,\r\n  };\r\n  // Load the wasm module and create an instance of using native support in the JS engine.\r\n  // handle a generated wasm instance, receiving its exports and\r\n  // performing other necessary setup\r\n  /** @param {WebAssembly.Module=} module*/\r\n  function receiveInstance(instance, module) {\r\n    var exports = instance.exports;\r\n\r\n    Module['asm'] = exports;\r\n\r\n    wasmMemory = Module['asm']['memory'];\r\n    assert(wasmMemory, \"memory not found in wasm exports\");\r\n    // This assertion doesn't hold when emscripten is run in --post-link\r\n    // mode.\r\n    // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.\r\n    //assert(wasmMemory.buffer.byteLength === 16777216);\r\n    updateMemoryViews();\r\n\r\n    wasmTable = Module['asm']['__indirect_function_table'];\r\n    assert(wasmTable, \"table not found in wasm exports\");\r\n\r\n    addOnInit(Module['asm']['__wasm_call_ctors']);\r\n\r\n    removeRunDependency('wasm-instantiate');\r\n    return exports;\r\n  }\r\n  // wait for the pthread pool (if any)\r\n  addRunDependency('wasm-instantiate');\r\n\r\n  // Prefer streaming instantiation if available.\r\n  // Async compilation can be confusing when an error on the page overwrites Module\r\n  // (for example, if the order of elements is wrong, and the one defining Module is\r\n  // later), so we save Module and check it later.\r\n  var trueModule = Module;\r\n  function receiveInstantiationResult(result) {\r\n    // 'result' is a ResultObject object which has both the module and instance.\r\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\r\n    trueModule = null;\r\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\r\n    // When the regression is fixed, can restore the above PTHREADS-enabled path.\r\n    receiveInstance(result['instance']);\r\n  }\r\n\r\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\r\n  // to manually instantiate the Wasm module themselves. This allows pages to\r\n  // run the instantiation parallel to any other async startup actions they are\r\n  // performing.\r\n  // Also pthreads and wasm workers initialize the wasm instance through this\r\n  // path.\r\n  if (Module['instantiateWasm']) {\r\n\r\n    try {\r\n      return Module['instantiateWasm'](info, receiveInstance);\r\n    } catch(e) {\r\n      err('Module.instantiateWasm callback failed with error: ' + e);\r\n        // If instantiation fails, reject the module ready promise.\r\n        readyPromiseReject(e);\r\n    }\r\n  }\r\n\r\n  // If instantiation fails, reject the module ready promise.\r\n  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\r\n  return {}; // no exports yet; we'll fill them in later\r\n}\r\n\r\n// include: runtime_debug.js\r\nfunction legacyModuleProp(prop, newName) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    Object.defineProperty(Module, prop, {\r\n      configurable: true,\r\n      get: function() {\r\n        abort('Module.' + prop + ' has been replaced with plain ' + newName + ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)');\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction ignoredModuleProp(prop) {\r\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    abort('`Module.' + prop + '` was supplied but `' + prop + '` not included in INCOMING_MODULE_JS_API');\r\n  }\r\n}\r\n\r\n// forcing the filesystem exports a few things by default\r\nfunction isExportedByForceFilesystem(name) {\r\n  return name === 'FS_createPath' ||\r\n         name === 'FS_createDataFile' ||\r\n         name === 'FS_createPreloadedFile' ||\r\n         name === 'FS_unlink' ||\r\n         name === 'addRunDependency' ||\r\n         // The old FS has some functionality that WasmFS lacks.\r\n         name === 'FS_createLazyFile' ||\r\n         name === 'FS_createDevice' ||\r\n         name === 'removeRunDependency';\r\n}\r\n\r\nfunction missingGlobal(sym, msg) {\r\n  if (typeof globalThis !== 'undefined') {\r\n    Object.defineProperty(globalThis, sym, {\r\n      configurable: true,\r\n      get: function() {\r\n        warnOnce('`' + sym + '` is not longer defined by emscripten. ' + msg);\r\n        return undefined;\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nmissingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\r\n\r\nfunction missingLibrarySymbol(sym) {\r\n  if (typeof globalThis !== 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\r\n    Object.defineProperty(globalThis, sym, {\r\n      configurable: true,\r\n      get: function() {\r\n        // Can't `abort()` here because it would break code that does runtime\r\n        // checks.  e.g. `if (typeof SDL === 'undefined')`.\r\n        var msg = '`' + sym + '` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line';\r\n        // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\r\n        // library.js, which means $name for a JS name with no prefix, or name\r\n        // for a JS name like _name.\r\n        var librarySymbol = sym;\r\n        if (!librarySymbol.startsWith('_')) {\r\n          librarySymbol = '$' + sym;\r\n        }\r\n        msg += \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=\" + librarySymbol + \")\";\r\n        if (isExportedByForceFilesystem(sym)) {\r\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\r\n        }\r\n        warnOnce(msg);\r\n        return undefined;\r\n      }\r\n    });\r\n  }\r\n  // Any symbol that is not included from the JS libary is also (by definition)\r\n  // not exported on the Module object.\r\n  unexportedRuntimeSymbol(sym);\r\n}\r\n\r\nfunction unexportedRuntimeSymbol(sym) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\r\n    Object.defineProperty(Module, sym, {\r\n      configurable: true,\r\n      get: function() {\r\n        var msg = \"'\" + sym + \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\";\r\n        if (isExportedByForceFilesystem(sym)) {\r\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\r\n        }\r\n        abort(msg);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// Used by XXXXX_DEBUG settings to output debug messages.\r\nfunction dbg(text) {\r\n  // TODO(sbc): Make this configurable somehow.  Its not always convenient for\r\n  // logging to show up as warnings.\r\n  console.warn.apply(console, arguments);\r\n}\r\n\r\n// end include: runtime_debug.js\r\n// === Body ===\r\n\r\n\r\n// end include: preamble.js\r\n\r\n  /** @constructor */\r\n  function ExitStatus(status) {\r\n      this.name = 'ExitStatus';\r\n      this.message = `Program terminated with exit(${status})`;\r\n      this.status = status;\r\n    }\r\n\r\n  function callRuntimeCallbacks(callbacks) {\r\n      while (callbacks.length > 0) {\r\n        // Pass the module as the first argument.\r\n        callbacks.shift()(Module);\r\n      }\r\n    }\r\n\r\n  \r\n    /**\r\n     * @param {number} ptr\r\n     * @param {string} type\r\n     */\r\n  function getValue(ptr, type = 'i8') {\r\n    if (type.endsWith('*')) type = '*';\r\n    switch (type) {\r\n      case 'i1': return HEAP8[((ptr)>>0)];\r\n      case 'i8': return HEAP8[((ptr)>>0)];\r\n      case 'i16': return HEAP16[((ptr)>>1)];\r\n      case 'i32': return HEAP32[((ptr)>>2)];\r\n      case 'i64': return HEAP64[((ptr)>>3)];\r\n      case 'float': return HEAPF32[((ptr)>>2)];\r\n      case 'double': return HEAPF64[((ptr)>>3)];\r\n      case '*': return HEAPU32[((ptr)>>2)];\r\n      default: abort(`invalid type for getValue: ${type}`);\r\n    }\r\n  }\r\n\r\n  function ptrToString(ptr) {\r\n      assert(typeof ptr === 'number');\r\n      return '0x' + ptr.toString(16).padStart(8, '0');\r\n    }\r\n\r\n  \r\n    /**\r\n     * @param {number} ptr\r\n     * @param {number} value\r\n     * @param {string} type\r\n     */\r\n  function setValue(ptr, value, type = 'i8') {\r\n    if (type.endsWith('*')) type = '*';\r\n    switch (type) {\r\n      case 'i1': HEAP8[((ptr)>>0)] = value; break;\r\n      case 'i8': HEAP8[((ptr)>>0)] = value; break;\r\n      case 'i16': HEAP16[((ptr)>>1)] = value; break;\r\n      case 'i32': HEAP32[((ptr)>>2)] = value; break;\r\n      case 'i64': HEAP64[((ptr)>>3)] = BigInt(value); break;\r\n      case 'float': HEAPF32[((ptr)>>2)] = value; break;\r\n      case 'double': HEAPF64[((ptr)>>3)] = value; break;\r\n      case '*': HEAPU32[((ptr)>>2)] = value; break;\r\n      default: abort(`invalid type for setValue: ${type}`);\r\n    }\r\n  }\r\n\r\n  function warnOnce(text) {\r\n      if (!warnOnce.shown) warnOnce.shown = {};\r\n      if (!warnOnce.shown[text]) {\r\n        warnOnce.shown[text] = 1;\r\n        if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;\r\n        err(text);\r\n      }\r\n    }\r\n\r\n  /** @constructor */\r\n  function ExceptionInfo(excPtr) {\r\n      this.excPtr = excPtr;\r\n      this.ptr = excPtr - 24;\r\n  \r\n      this.set_type = function(type) {\r\n        HEAPU32[(((this.ptr)+(4))>>2)] = type;\r\n      };\r\n  \r\n      this.get_type = function() {\r\n        return HEAPU32[(((this.ptr)+(4))>>2)];\r\n      };\r\n  \r\n      this.set_destructor = function(destructor) {\r\n        HEAPU32[(((this.ptr)+(8))>>2)] = destructor;\r\n      };\r\n  \r\n      this.get_destructor = function() {\r\n        return HEAPU32[(((this.ptr)+(8))>>2)];\r\n      };\r\n  \r\n      this.set_caught = function (caught) {\r\n        caught = caught ? 1 : 0;\r\n        HEAP8[(((this.ptr)+(12))>>0)] = caught;\r\n      };\r\n  \r\n      this.get_caught = function () {\r\n        return HEAP8[(((this.ptr)+(12))>>0)] != 0;\r\n      };\r\n  \r\n      this.set_rethrown = function (rethrown) {\r\n        rethrown = rethrown ? 1 : 0;\r\n        HEAP8[(((this.ptr)+(13))>>0)] = rethrown;\r\n      };\r\n  \r\n      this.get_rethrown = function () {\r\n        return HEAP8[(((this.ptr)+(13))>>0)] != 0;\r\n      };\r\n  \r\n      // Initialize native structure fields. Should be called once after allocated.\r\n      this.init = function(type, destructor) {\r\n        this.set_adjusted_ptr(0);\r\n        this.set_type(type);\r\n        this.set_destructor(destructor);\r\n      }\r\n  \r\n      this.set_adjusted_ptr = function(adjustedPtr) {\r\n        HEAPU32[(((this.ptr)+(16))>>2)] = adjustedPtr;\r\n      };\r\n  \r\n      this.get_adjusted_ptr = function() {\r\n        return HEAPU32[(((this.ptr)+(16))>>2)];\r\n      };\r\n  \r\n      // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted\r\n      // when the pointer is casted to some of the exception object base classes (e.g. when virtual\r\n      // inheritance is used). When a pointer is thrown this method should return the thrown pointer\r\n      // itself.\r\n      this.get_exception_ptr = function() {\r\n        // Work around a fastcomp bug, this code is still included for some reason in a build without\r\n        // exceptions support.\r\n        var isPointer = ___cxa_is_pointer_type(this.get_type());\r\n        if (isPointer) {\r\n          return HEAPU32[((this.excPtr)>>2)];\r\n        }\r\n        var adjusted = this.get_adjusted_ptr();\r\n        if (adjusted !== 0) return adjusted;\r\n        return this.excPtr;\r\n      };\r\n    }\r\n  \r\n  var exceptionLast = 0;\r\n  \r\n  var uncaughtExceptionCount = 0;\r\n  function ___cxa_throw(ptr, type, destructor) {\r\n      var info = new ExceptionInfo(ptr);\r\n      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\r\n      info.init(type, destructor);\r\n      exceptionLast = ptr;\r\n      uncaughtExceptionCount++;\r\n      assert(false, 'Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.');\r\n    }\r\n\r\n  var tupleRegistrations = {};\r\n  \r\n  function runDestructors(destructors) {\r\n      while (destructors.length) {\r\n        var ptr = destructors.pop();\r\n        var del = destructors.pop();\r\n        del(ptr);\r\n      }\r\n    }\r\n  \r\n  function simpleReadValueFromPointer(pointer) {\r\n      return this['fromWireType'](HEAP32[((pointer)>>2)]);\r\n    }\r\n  \r\n  var awaitingDependencies = {};\r\n  \r\n  var registeredTypes = {};\r\n  \r\n  var typeDependencies = {};\r\n  \r\n  var char_0 = 48;\r\n  \r\n  var char_9 = 57;\r\n  function makeLegalFunctionName(name) {\r\n      if (undefined === name) {\r\n        return '_unknown';\r\n      }\r\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\r\n      var f = name.charCodeAt(0);\r\n      if (f >= char_0 && f <= char_9) {\r\n        return `_${name}`;\r\n      }\r\n      return name;\r\n    }\r\n  function createNamedFunction(name, body) {\r\n      name = makeLegalFunctionName(name);\r\n      // Use an abject with a computed property name to create a new function with\r\n      // a name specified at runtime, but without using `new Function` or `eval`.\r\n      return {\r\n        [name]: function() {\r\n          return body.apply(this, arguments);\r\n        }\r\n      }[name];\r\n    }\r\n  function extendError(baseErrorType, errorName) {\r\n      var errorClass = createNamedFunction(errorName, function(message) {\r\n        this.name = errorName;\r\n        this.message = message;\r\n  \r\n        var stack = (new Error(message)).stack;\r\n        if (stack !== undefined) {\r\n          this.stack = this.toString() + '\\n' +\r\n              stack.replace(/^Error(:[^\\n]*)?\\n/, '');\r\n        }\r\n      });\r\n      errorClass.prototype = Object.create(baseErrorType.prototype);\r\n      errorClass.prototype.constructor = errorClass;\r\n      errorClass.prototype.toString = function() {\r\n        if (this.message === undefined) {\r\n          return this.name;\r\n        } else {\r\n          return `${this.name}: ${this.message}`;\r\n        }\r\n      };\r\n  \r\n      return errorClass;\r\n    }\r\n  var InternalError = undefined;\r\n  function throwInternalError(message) {\r\n      throw new InternalError(message);\r\n    }\r\n  function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\r\n      myTypes.forEach(function(type) {\r\n          typeDependencies[type] = dependentTypes;\r\n      });\r\n  \r\n      function onComplete(typeConverters) {\r\n          var myTypeConverters = getTypeConverters(typeConverters);\r\n          if (myTypeConverters.length !== myTypes.length) {\r\n              throwInternalError('Mismatched type converter count');\r\n          }\r\n          for (var i = 0; i < myTypes.length; ++i) {\r\n              registerType(myTypes[i], myTypeConverters[i]);\r\n          }\r\n      }\r\n  \r\n      var typeConverters = new Array(dependentTypes.length);\r\n      var unregisteredTypes = [];\r\n      var registered = 0;\r\n      dependentTypes.forEach((dt, i) => {\r\n        if (registeredTypes.hasOwnProperty(dt)) {\r\n          typeConverters[i] = registeredTypes[dt];\r\n        } else {\r\n          unregisteredTypes.push(dt);\r\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\r\n            awaitingDependencies[dt] = [];\r\n          }\r\n          awaitingDependencies[dt].push(() => {\r\n            typeConverters[i] = registeredTypes[dt];\r\n            ++registered;\r\n            if (registered === unregisteredTypes.length) {\r\n              onComplete(typeConverters);\r\n            }\r\n          });\r\n        }\r\n      });\r\n      if (0 === unregisteredTypes.length) {\r\n        onComplete(typeConverters);\r\n      }\r\n    }\r\n  function __embind_finalize_value_array(rawTupleType) {\r\n      var reg = tupleRegistrations[rawTupleType];\r\n      delete tupleRegistrations[rawTupleType];\r\n      var elements = reg.elements;\r\n      var elementsLength = elements.length;\r\n      var elementTypes = elements.map(function(elt) { return elt.getterReturnType; }).\r\n                  concat(elements.map(function(elt) { return elt.setterArgumentType; }));\r\n  \r\n      var rawConstructor = reg.rawConstructor;\r\n      var rawDestructor = reg.rawDestructor;\r\n  \r\n      whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes) {\r\n        elements.forEach((elt, i) => {\r\n          var getterReturnType = elementTypes[i];\r\n          var getter = elt.getter;\r\n          var getterContext = elt.getterContext;\r\n          var setterArgumentType = elementTypes[i + elementsLength];\r\n          var setter = elt.setter;\r\n          var setterContext = elt.setterContext;\r\n          elt.read = (ptr) => {\r\n            return getterReturnType['fromWireType'](getter(getterContext, ptr));\r\n          };\r\n          elt.write = (ptr, o) => {\r\n            var destructors = [];\r\n            setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));\r\n            runDestructors(destructors);\r\n          };\r\n        });\r\n  \r\n        return [{\r\n          name: reg.name,\r\n          'fromWireType': function(ptr) {\r\n            var rv = new Array(elementsLength);\r\n            for (var i = 0; i < elementsLength; ++i) {\r\n              rv[i] = elements[i].read(ptr);\r\n            }\r\n            rawDestructor(ptr);\r\n            return rv;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n            if (elementsLength !== o.length) {\r\n              throw new TypeError(`Incorrect number of tuple elements for ${reg.name}: expected=${elementsLength}, actual=${o.length}`);\r\n            }\r\n            var ptr = rawConstructor();\r\n            for (var i = 0; i < elementsLength; ++i) {\r\n              elements[i].write(ptr, o[i]);\r\n            }\r\n            if (destructors !== null) {\r\n              destructors.push(rawDestructor, ptr);\r\n            }\r\n            return ptr;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': simpleReadValueFromPointer,\r\n          destructorFunction: rawDestructor,\r\n        }];\r\n      });\r\n    }\r\n\r\n  var structRegistrations = {};\r\n  \r\n  \r\n  \r\n  function __embind_finalize_value_object(structType) {\r\n      var reg = structRegistrations[structType];\r\n      delete structRegistrations[structType];\r\n  \r\n      var rawConstructor = reg.rawConstructor;\r\n      var rawDestructor = reg.rawDestructor;\r\n      var fieldRecords = reg.fields;\r\n      var fieldTypes = fieldRecords.map((field) => field.getterReturnType).\r\n                concat(fieldRecords.map((field) => field.setterArgumentType));\r\n      whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes) => {\r\n        var fields = {};\r\n        fieldRecords.forEach((field, i) => {\r\n          var fieldName = field.fieldName;\r\n          var getterReturnType = fieldTypes[i];\r\n          var getter = field.getter;\r\n          var getterContext = field.getterContext;\r\n          var setterArgumentType = fieldTypes[i + fieldRecords.length];\r\n          var setter = field.setter;\r\n          var setterContext = field.setterContext;\r\n          fields[fieldName] = {\r\n            read: (ptr) => {\r\n              return getterReturnType['fromWireType'](\r\n                  getter(getterContext, ptr));\r\n            },\r\n            write: (ptr, o) => {\r\n              var destructors = [];\r\n              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));\r\n              runDestructors(destructors);\r\n            }\r\n          };\r\n        });\r\n  \r\n        return [{\r\n          name: reg.name,\r\n          'fromWireType': function(ptr) {\r\n            var rv = {};\r\n            for (var i in fields) {\r\n              rv[i] = fields[i].read(ptr);\r\n            }\r\n            rawDestructor(ptr);\r\n            return rv;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n            // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations:\r\n            // assume all fields are present without checking.\r\n            for (var fieldName in fields) {\r\n              if (!(fieldName in o)) {\r\n                throw new TypeError(`Missing field: \"${fieldName}\"`);\r\n              }\r\n            }\r\n            var ptr = rawConstructor();\r\n            for (fieldName in fields) {\r\n              fields[fieldName].write(ptr, o[fieldName]);\r\n            }\r\n            if (destructors !== null) {\r\n              destructors.push(rawDestructor, ptr);\r\n            }\r\n            return ptr;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': simpleReadValueFromPointer,\r\n          destructorFunction: rawDestructor,\r\n        }];\r\n      });\r\n    }\r\n\r\n  function embindRepr(v) {\r\n      if (v === null) {\r\n          return 'null';\r\n      }\r\n      var t = typeof v;\r\n      if (t === 'object' || t === 'array' || t === 'function') {\r\n          return v.toString();\r\n      } else {\r\n          return '' + v;\r\n      }\r\n    }\r\n  \r\n  function embind_init_charCodes() {\r\n      var codes = new Array(256);\r\n      for (var i = 0; i < 256; ++i) {\r\n          codes[i] = String.fromCharCode(i);\r\n      }\r\n      embind_charCodes = codes;\r\n    }\r\n  var embind_charCodes = undefined;\r\n  function readLatin1String(ptr) {\r\n      var ret = \"\";\r\n      var c = ptr;\r\n      while (HEAPU8[c]) {\r\n          ret += embind_charCodes[HEAPU8[c++]];\r\n      }\r\n      return ret;\r\n    }\r\n  \r\n  \r\n  \r\n  \r\n  var BindingError = undefined;\r\n  function throwBindingError(message) {\r\n      throw new BindingError(message);\r\n    }\r\n  \r\n  /** @param {Object=} options */\r\n  function registerType(rawType, registeredInstance, options = {}) {\r\n      if (!('argPackAdvance' in registeredInstance)) {\r\n        throw new TypeError('registerType registeredInstance requires argPackAdvance');\r\n      }\r\n  \r\n      var name = registeredInstance.name;\r\n      if (!rawType) {\r\n        throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\r\n      }\r\n      if (registeredTypes.hasOwnProperty(rawType)) {\r\n        if (options.ignoreDuplicateRegistrations) {\r\n          return;\r\n        } else {\r\n          throwBindingError(`Cannot register type '${name}' twice`);\r\n        }\r\n      }\r\n  \r\n      registeredTypes[rawType] = registeredInstance;\r\n      delete typeDependencies[rawType];\r\n  \r\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\r\n        var callbacks = awaitingDependencies[rawType];\r\n        delete awaitingDependencies[rawType];\r\n        callbacks.forEach((cb) => cb());\r\n      }\r\n    }\r\n  \r\n  function integerReadValueFromPointer(name, shift, signed) {\r\n      // integers are quite common, so generate very specialized functions\r\n      switch (shift) {\r\n          case 0: return signed ?\r\n              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :\r\n              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };\r\n          case 1: return signed ?\r\n              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :\r\n              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };\r\n          case 2: return signed ?\r\n              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :\r\n              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };\r\n          case 3: return signed ?\r\n              function readS64FromPointer(pointer) { return HEAP64[pointer >> 3]; } :\r\n              function readU64FromPointer(pointer) { return HEAPU64[pointer >> 3]; };\r\n          default:\r\n              throw new TypeError(\"Unknown integer type: \" + name);\r\n      }\r\n    }\r\n  function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {\r\n      name = readLatin1String(name);\r\n  \r\n      var shift = getShiftFromSize(size);\r\n  \r\n      var isUnsignedType = (name.indexOf('u') != -1);\r\n  \r\n      // maxRange comes through as -1 for uint64_t (see issue 13902). Work around that temporarily\r\n      if (isUnsignedType) {\r\n        maxRange = (1n << 64n) - 1n;\r\n      }\r\n  \r\n      registerType(primitiveType, {\r\n        name: name,\r\n        'fromWireType': function (value) {\r\n          return value;\r\n        },\r\n        'toWireType': function (destructors, value) {\r\n          if (typeof value != \"bigint\" && typeof value != \"number\") {\r\n            throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${this.name}`);\r\n          }\r\n          if (value < minRange || value > maxRange) {\r\n            throw new TypeError(`Passing a number \"${embindRepr(value)}\" from JS side to C/C++ side to an argument of type \"${name}\", which is outside the valid range [${minRange}, ${maxRange}]!`);\r\n          }\r\n          return value;\r\n        },\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': integerReadValueFromPointer(name, shift, !isUnsignedType),\r\n        destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  function getShiftFromSize(size) {\r\n      switch (size) {\r\n          case 1: return 0;\r\n          case 2: return 1;\r\n          case 4: return 2;\r\n          case 8: return 3;\r\n          default:\r\n              throw new TypeError(`Unknown type size: ${size}`);\r\n      }\r\n    }\r\n  \r\n  \r\n  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\r\n      var shift = getShiftFromSize(size);\r\n  \r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n          name: name,\r\n          'fromWireType': function(wt) {\r\n              // ambiguous emscripten ABI: sometimes return values are\r\n              // true or false, and sometimes integers (0 or 1)\r\n              return !!wt;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n              return o ? trueValue : falseValue;\r\n          },\r\n          'argPackAdvance': 8,\r\n          'readValueFromPointer': function(pointer) {\r\n              // TODO: if heap is fixed (like in asm.js) this could be executed outside\r\n              var heap;\r\n              if (size === 1) {\r\n                  heap = HEAP8;\r\n              } else if (size === 2) {\r\n                  heap = HEAP16;\r\n              } else if (size === 4) {\r\n                  heap = HEAP32;\r\n              } else {\r\n                  throw new TypeError(\"Unknown boolean type size: \" + name);\r\n              }\r\n              return this['fromWireType'](heap[pointer >> shift]);\r\n          },\r\n          destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  \r\n  function __embind_register_constant(name, type, value) {\r\n      name = readLatin1String(name);\r\n      whenDependentTypesAreResolved([], [type], function(type) {\r\n        type = type[0];\r\n        Module[name] = type['fromWireType'](value);\r\n        return [];\r\n      });\r\n    }\r\n\r\n  /** @constructor */\r\n  function HandleAllocator() {\r\n      // Reserve slot 0 so that 0 is always an invalid handle\r\n      this.allocated = [undefined];\r\n      this.freelist = [];\r\n      this.get = function(id) {\r\n        assert(this.allocated[id] !== undefined, `invalid handle: ${id}`);\r\n        return this.allocated[id];\r\n      };\r\n      this.has = function(id) {\r\n        return this.allocated[id] !== undefined;\r\n      };\r\n      this.allocate = function(handle) {\r\n        var id = this.freelist.pop() || this.allocated.length;\r\n        this.allocated[id] = handle;\r\n        return id;\r\n      };\r\n      this.free = function(id) {\r\n        assert(this.allocated[id] !== undefined);\r\n        // Set the slot to `undefined` rather than using `delete` here since\r\n        // apparently arrays with holes in them can be less efficient.\r\n        this.allocated[id] = undefined;\r\n        this.freelist.push(id);\r\n      };\r\n    }\r\n  var emval_handles = new HandleAllocator();;\r\n  function __emval_decref(handle) {\r\n      if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {\r\n        emval_handles.free(handle);\r\n      }\r\n    }\r\n  \r\n  \r\n  \r\n  function count_emval_handles() {\r\n      var count = 0;\r\n      for (var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) {\r\n        if (emval_handles.allocated[i] !== undefined) {\r\n          ++count;\r\n        }\r\n      }\r\n      return count;\r\n    }\r\n  \r\n  function init_emval() {\r\n      // reserve some special values. These never get de-allocated.\r\n      // The HandleAllocator takes care of reserving zero.\r\n      emval_handles.allocated.push(\r\n        {value: undefined},\r\n        {value: null},\r\n        {value: true},\r\n        {value: false},\r\n      );\r\n      emval_handles.reserved = emval_handles.allocated.length\r\n      Module['count_emval_handles'] = count_emval_handles;\r\n    }\r\n  var Emval = {toValue:(handle) => {\r\n        if (!handle) {\r\n            throwBindingError('Cannot use deleted val. handle = ' + handle);\r\n        }\r\n        return emval_handles.get(handle).value;\r\n      },toHandle:(value) => {\r\n        switch (value) {\r\n          case undefined: return 1;\r\n          case null: return 2;\r\n          case true: return 3;\r\n          case false: return 4;\r\n          default:{\r\n            return emval_handles.allocate({refcount: 1, value: value});\r\n          }\r\n        }\r\n      }};\r\n  \r\n  \r\n  \r\n  function __embind_register_emval(rawType, name) {\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': function(handle) {\r\n          var rv = Emval.toValue(handle);\r\n          __emval_decref(handle);\r\n          return rv;\r\n        },\r\n        'toWireType': function(destructors, value) {\r\n          return Emval.toHandle(value);\r\n        },\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': simpleReadValueFromPointer,\r\n        destructorFunction: null, // This type does not need a destructor\r\n  \r\n        // TODO: do we need a deleteObject here?  write a test where\r\n        // emval is passed into JS via an interface\r\n      });\r\n    }\r\n\r\n  \r\n  function floatReadValueFromPointer(name, shift) {\r\n      switch (shift) {\r\n          case 2: return function(pointer) {\r\n              return this['fromWireType'](HEAPF32[pointer >> 2]);\r\n          };\r\n          case 3: return function(pointer) {\r\n              return this['fromWireType'](HEAPF64[pointer >> 3]);\r\n          };\r\n          default:\r\n              throw new TypeError(\"Unknown float type: \" + name);\r\n      }\r\n    }\r\n  \r\n  \r\n  \r\n  function __embind_register_float(rawType, name, size) {\r\n      var shift = getShiftFromSize(size);\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': function(value) {\r\n           return value;\r\n        },\r\n        'toWireType': function(destructors, value) {\r\n          if (typeof value != \"number\" && typeof value != \"boolean\") {\r\n            throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);\r\n          }\r\n          // The VM will perform JS to Wasm value conversion, according to the spec:\r\n          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n          return value;\r\n        },\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': floatReadValueFromPointer(name, shift),\r\n        destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  \r\n  \r\n  \r\n  \r\n  function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\r\n      name = readLatin1String(name);\r\n      // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come\r\n      // out as 'i32 -1'. Always treat those as max u32.\r\n      if (maxRange === -1) {\r\n          maxRange = 4294967295;\r\n      }\r\n  \r\n      var shift = getShiftFromSize(size);\r\n  \r\n      var fromWireType = (value) => value;\r\n  \r\n      if (minRange === 0) {\r\n          var bitshift = 32 - 8*size;\r\n          fromWireType = (value) => (value << bitshift) >>> bitshift;\r\n      }\r\n  \r\n      var isUnsignedType = (name.includes('unsigned'));\r\n      var checkAssertions = (value, toTypeName) => {\r\n        if (typeof value != \"number\" && typeof value != \"boolean\") {\r\n          throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${toTypeName}`);\r\n        }\r\n        if (value < minRange || value > maxRange) {\r\n          throw new TypeError(`Passing a number \"${embindRepr(value)}\" from JS side to C/C++ side to an argument of type \"${name}\", which is outside the valid range [${minRange}, ${maxRange}]!`);\r\n        }\r\n      }\r\n      var toWireType;\r\n      if (isUnsignedType) {\r\n        toWireType = function(destructors, value) {\r\n          checkAssertions(value, this.name);\r\n          return value >>> 0;\r\n        }\r\n      } else {\r\n        toWireType = function(destructors, value) {\r\n          checkAssertions(value, this.name);\r\n          // The VM will perform JS to Wasm value conversion, according to the spec:\r\n          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n          return value;\r\n        }\r\n      }\r\n      registerType(primitiveType, {\r\n        name: name,\r\n        'fromWireType': fromWireType,\r\n        'toWireType': toWireType,\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),\r\n        destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    }\r\n\r\n  \r\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\r\n      var typeMapping = [\r\n        Int8Array,\r\n        Uint8Array,\r\n        Int16Array,\r\n        Uint16Array,\r\n        Int32Array,\r\n        Uint32Array,\r\n        Float32Array,\r\n        Float64Array,\r\n        BigInt64Array,\r\n        BigUint64Array,\r\n      ];\r\n  \r\n      var TA = typeMapping[dataTypeIndex];\r\n  \r\n      function decodeMemoryView(handle) {\r\n        handle = handle >> 2;\r\n        var heap = HEAPU32;\r\n        var size = heap[handle]; // in elements\r\n        var data = heap[handle + 1]; // byte offset into emscripten heap\r\n        return new TA(heap.buffer, data, size);\r\n      }\r\n  \r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': decodeMemoryView,\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': decodeMemoryView,\r\n      }, {\r\n        ignoreDuplicateRegistrations: true,\r\n      });\r\n    }\r\n\r\n  \r\n  \r\n  \r\n  \r\n  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\r\n      assert(typeof str === 'string');\r\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\r\n      // undefined and false each don't write out any bytes.\r\n      if (!(maxBytesToWrite > 0))\r\n        return 0;\r\n  \r\n      var startIdx = outIdx;\r\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n        // unit, not a Unicode code point of the character! So decode\r\n        // UTF16->UTF32->UTF8.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\r\n        // and https://www.ietf.org/rfc/rfc2279.txt\r\n        // and https://tools.ietf.org/html/rfc3629\r\n        var u = str.charCodeAt(i); // possibly a lead surrogate\r\n        if (u >= 0xD800 && u <= 0xDFFF) {\r\n          var u1 = str.charCodeAt(++i);\r\n          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\r\n        }\r\n        if (u <= 0x7F) {\r\n          if (outIdx >= endIdx) break;\r\n          heap[outIdx++] = u;\r\n        } else if (u <= 0x7FF) {\r\n          if (outIdx + 1 >= endIdx) break;\r\n          heap[outIdx++] = 0xC0 | (u >> 6);\r\n          heap[outIdx++] = 0x80 | (u & 63);\r\n        } else if (u <= 0xFFFF) {\r\n          if (outIdx + 2 >= endIdx) break;\r\n          heap[outIdx++] = 0xE0 | (u >> 12);\r\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n          heap[outIdx++] = 0x80 | (u & 63);\r\n        } else {\r\n          if (outIdx + 3 >= endIdx) break;\r\n          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\r\n          heap[outIdx++] = 0xF0 | (u >> 18);\r\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n          heap[outIdx++] = 0x80 | (u & 63);\r\n        }\r\n      }\r\n      // Null-terminate the pointer to the buffer.\r\n      heap[outIdx] = 0;\r\n      return outIdx - startIdx;\r\n    }\r\n  function stringToUTF8(str, outPtr, maxBytesToWrite) {\r\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n      return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\r\n    }\r\n  \r\n  function lengthBytesUTF8(str) {\r\n      var len = 0;\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n        // unit, not a Unicode code point of the character! So decode\r\n        // UTF16->UTF32->UTF8.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        var c = str.charCodeAt(i); // possibly a lead surrogate\r\n        if (c <= 0x7F) {\r\n          len++;\r\n        } else if (c <= 0x7FF) {\r\n          len += 2;\r\n        } else if (c >= 0xD800 && c <= 0xDFFF) {\r\n          len += 4; ++i;\r\n        } else {\r\n          len += 3;\r\n        }\r\n      }\r\n      return len;\r\n    }\r\n  \r\n  \r\n  \r\n  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\r\n  \r\n    /**\r\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\r\n     * array that contains uint8 values, returns a copy of that string as a\r\n     * Javascript String object.\r\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n     * @param {number} idx\r\n     * @param {number=} maxBytesToRead\r\n     * @return {string}\r\n     */\r\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\r\n      var endIdx = idx + maxBytesToRead;\r\n      var endPtr = idx;\r\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\r\n      // null terminator by itself.  Also, use the length info to avoid running tiny\r\n      // strings through TextDecoder, since .subarray() allocates garbage.\r\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\r\n      // so that undefined means Infinity)\r\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n  \r\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\r\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\r\n      }\r\n      var str = '';\r\n      // If building with TextDecoder, we have already computed the string length\r\n      // above, so test loop end condition against that\r\n      while (idx < endPtr) {\r\n        // For UTF8 byte structure, see:\r\n        // http://en.wikipedia.org/wiki/UTF-8#Description\r\n        // https://www.ietf.org/rfc/rfc2279.txt\r\n        // https://tools.ietf.org/html/rfc3629\r\n        var u0 = heapOrArray[idx++];\r\n        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\r\n        var u1 = heapOrArray[idx++] & 63;\r\n        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\r\n        var u2 = heapOrArray[idx++] & 63;\r\n        if ((u0 & 0xF0) == 0xE0) {\r\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n        } else {\r\n          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\r\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\r\n        }\r\n  \r\n        if (u0 < 0x10000) {\r\n          str += String.fromCharCode(u0);\r\n        } else {\r\n          var ch = u0 - 0x10000;\r\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n        }\r\n      }\r\n      return str;\r\n    }\r\n  \r\n  \r\n    /**\r\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\r\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\r\n     *\r\n     * @param {number} ptr\r\n     * @param {number=} maxBytesToRead - An optional length that specifies the\r\n     *   maximum number of bytes to read. You can omit this parameter to scan the\r\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\r\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\r\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\r\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\r\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\r\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\r\n     * @return {string}\r\n     */\r\n  function UTF8ToString(ptr, maxBytesToRead) {\r\n      assert(typeof ptr == 'number');\r\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\r\n    }\r\n  function __embind_register_std_string(rawType, name) {\r\n      name = readLatin1String(name);\r\n      var stdStringIsUTF8\r\n      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>\r\n      = (name === \"std::string\");\r\n  \r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': function(value) {\r\n          var length = HEAPU32[((value)>>2)];\r\n          var payload = value + 4;\r\n  \r\n          var str;\r\n          if (stdStringIsUTF8) {\r\n            var decodeStartPtr = payload;\r\n            // Looping here to support possible embedded '0' bytes\r\n            for (var i = 0; i <= length; ++i) {\r\n              var currentBytePtr = payload + i;\r\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\r\n                var maxRead = currentBytePtr - decodeStartPtr;\r\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\r\n                if (str === undefined) {\r\n                  str = stringSegment;\r\n                } else {\r\n                  str += String.fromCharCode(0);\r\n                  str += stringSegment;\r\n                }\r\n                decodeStartPtr = currentBytePtr + 1;\r\n              }\r\n            }\r\n          } else {\r\n            var a = new Array(length);\r\n            for (var i = 0; i < length; ++i) {\r\n              a[i] = String.fromCharCode(HEAPU8[payload + i]);\r\n            }\r\n            str = a.join('');\r\n          }\r\n  \r\n          _free(value);\r\n  \r\n          return str;\r\n        },\r\n        'toWireType': function(destructors, value) {\r\n          if (value instanceof ArrayBuffer) {\r\n            value = new Uint8Array(value);\r\n          }\r\n  \r\n          var length;\r\n          var valueIsOfTypeString = (typeof value == 'string');\r\n  \r\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\r\n            throwBindingError('Cannot pass non-string to std::string');\r\n          }\r\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n            length = lengthBytesUTF8(value);\r\n          } else {\r\n            length = value.length;\r\n          }\r\n  \r\n          // assumes 4-byte alignment\r\n          var base = _malloc(4 + length + 1);\r\n          var ptr = base + 4;\r\n          HEAPU32[((base)>>2)] = length;\r\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n            stringToUTF8(value, ptr, length + 1);\r\n          } else {\r\n            if (valueIsOfTypeString) {\r\n              for (var i = 0; i < length; ++i) {\r\n                var charCode = value.charCodeAt(i);\r\n                if (charCode > 255) {\r\n                  _free(ptr);\r\n                  throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\r\n                }\r\n                HEAPU8[ptr + i] = charCode;\r\n              }\r\n            } else {\r\n              for (var i = 0; i < length; ++i) {\r\n                HEAPU8[ptr + i] = value[i];\r\n              }\r\n            }\r\n          }\r\n  \r\n          if (destructors !== null) {\r\n            destructors.push(_free, base);\r\n          }\r\n          return base;\r\n        },\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': simpleReadValueFromPointer,\r\n        destructorFunction: function(ptr) { _free(ptr); },\r\n      });\r\n    }\r\n\r\n  \r\n  \r\n  \r\n  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;;\r\n  function UTF16ToString(ptr, maxBytesToRead) {\r\n      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\r\n      var endPtr = ptr;\r\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\r\n      // null terminator by itself.\r\n      // Also, use the length info to avoid running tiny strings through\r\n      // TextDecoder, since .subarray() allocates garbage.\r\n      var idx = endPtr >> 1;\r\n      var maxIdx = idx + maxBytesToRead / 2;\r\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n      // will always evaluate to true. This saves on code size.\r\n      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\r\n      endPtr = idx << 1;\r\n  \r\n      if (endPtr - ptr > 32 && UTF16Decoder)\r\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\r\n  \r\n      // Fallback: decode without UTF16Decoder\r\n      var str = '';\r\n  \r\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and the\r\n      // for-loop's condition will always evaluate to true. The loop is then\r\n      // terminated on the first null char.\r\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\r\n        var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\r\n        if (codeUnit == 0) break;\r\n        // fromCharCode constructs a character from a UTF-16 code unit, so we can\r\n        // pass the UTF16 string right through.\r\n        str += String.fromCharCode(codeUnit);\r\n      }\r\n  \r\n      return str;\r\n    }\r\n  \r\n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\r\n      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\r\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n      if (maxBytesToWrite === undefined) {\r\n        maxBytesToWrite = 0x7FFFFFFF;\r\n      }\r\n      if (maxBytesToWrite < 2) return 0;\r\n      maxBytesToWrite -= 2; // Null terminator.\r\n      var startPtr = outPtr;\r\n      var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\r\n      for (var i = 0; i < numCharsToWrite; ++i) {\r\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\r\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n        HEAP16[((outPtr)>>1)] = codeUnit;\r\n        outPtr += 2;\r\n      }\r\n      // Null-terminate the pointer to the HEAP.\r\n      HEAP16[((outPtr)>>1)] = 0;\r\n      return outPtr - startPtr;\r\n    }\r\n  \r\n  function lengthBytesUTF16(str) {\r\n      return str.length*2;\r\n    }\r\n  \r\n  function UTF32ToString(ptr, maxBytesToRead) {\r\n      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\r\n      var i = 0;\r\n  \r\n      var str = '';\r\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n      // will always evaluate to true. This saves on code size.\r\n      while (!(i >= maxBytesToRead / 4)) {\r\n        var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\r\n        if (utf32 == 0) break;\r\n        ++i;\r\n        // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        if (utf32 >= 0x10000) {\r\n          var ch = utf32 - 0x10000;\r\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n        } else {\r\n          str += String.fromCharCode(utf32);\r\n        }\r\n      }\r\n      return str;\r\n    }\r\n  \r\n  function stringToUTF32(str, outPtr, maxBytesToWrite) {\r\n      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\r\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n      if (maxBytesToWrite === undefined) {\r\n        maxBytesToWrite = 0x7FFFFFFF;\r\n      }\r\n      if (maxBytesToWrite < 4) return 0;\r\n      var startPtr = outPtr;\r\n      var endPtr = startPtr + maxBytesToWrite - 4;\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\r\n          var trailSurrogate = str.charCodeAt(++i);\r\n          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\r\n        }\r\n        HEAP32[((outPtr)>>2)] = codeUnit;\r\n        outPtr += 4;\r\n        if (outPtr + 4 > endPtr) break;\r\n      }\r\n      // Null-terminate the pointer to the HEAP.\r\n      HEAP32[((outPtr)>>2)] = 0;\r\n      return outPtr - startPtr;\r\n    }\r\n  \r\n  function lengthBytesUTF32(str) {\r\n      var len = 0;\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        var codeUnit = str.charCodeAt(i);\r\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\r\n        len += 4;\r\n      }\r\n  \r\n      return len;\r\n    }\r\n  function __embind_register_std_wstring(rawType, charSize, name) {\r\n      name = readLatin1String(name);\r\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\r\n      if (charSize === 2) {\r\n        decodeString = UTF16ToString;\r\n        encodeString = stringToUTF16;\r\n        lengthBytesUTF = lengthBytesUTF16;\r\n        getHeap = () => HEAPU16;\r\n        shift = 1;\r\n      } else if (charSize === 4) {\r\n        decodeString = UTF32ToString;\r\n        encodeString = stringToUTF32;\r\n        lengthBytesUTF = lengthBytesUTF32;\r\n        getHeap = () => HEAPU32;\r\n        shift = 2;\r\n      }\r\n      registerType(rawType, {\r\n        name: name,\r\n        'fromWireType': function(value) {\r\n          // Code mostly taken from _embind_register_std_string fromWireType\r\n          var length = HEAPU32[value >> 2];\r\n          var HEAP = getHeap();\r\n          var str;\r\n  \r\n          var decodeStartPtr = value + 4;\r\n          // Looping here to support possible embedded '0' bytes\r\n          for (var i = 0; i <= length; ++i) {\r\n            var currentBytePtr = value + 4 + i * charSize;\r\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\r\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\r\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\r\n              if (str === undefined) {\r\n                str = stringSegment;\r\n              } else {\r\n                str += String.fromCharCode(0);\r\n                str += stringSegment;\r\n              }\r\n              decodeStartPtr = currentBytePtr + charSize;\r\n            }\r\n          }\r\n  \r\n          _free(value);\r\n  \r\n          return str;\r\n        },\r\n        'toWireType': function(destructors, value) {\r\n          if (!(typeof value == 'string')) {\r\n            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\r\n          }\r\n  \r\n          // assumes 4-byte alignment\r\n          var length = lengthBytesUTF(value);\r\n          var ptr = _malloc(4 + length + charSize);\r\n          HEAPU32[ptr >> 2] = length >> shift;\r\n  \r\n          encodeString(value, ptr + 4, length + charSize);\r\n  \r\n          if (destructors !== null) {\r\n            destructors.push(_free, ptr);\r\n          }\r\n          return ptr;\r\n        },\r\n        'argPackAdvance': 8,\r\n        'readValueFromPointer': simpleReadValueFromPointer,\r\n        destructorFunction: function(ptr) { _free(ptr); },\r\n      });\r\n    }\r\n\r\n  \r\n  \r\n  \r\n  \r\n  var wasmTableMirror = [];\r\n  \r\n  function getWasmTableEntry(funcPtr) {\r\n      var func = wasmTableMirror[funcPtr];\r\n      if (!func) {\r\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\r\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\r\n      }\r\n      assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\r\n      return func;\r\n    }\r\n  function embind__requireFunction(signature, rawFunction) {\r\n      signature = readLatin1String(signature);\r\n  \r\n      function makeDynCaller() {\r\n        return getWasmTableEntry(rawFunction);\r\n      }\r\n  \r\n      var fp = makeDynCaller();\r\n      if (typeof fp != \"function\") {\r\n          throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\r\n      }\r\n      return fp;\r\n    }\r\n  function __embind_register_value_array(\r\n      rawType,\r\n      name,\r\n      constructorSignature,\r\n      rawConstructor,\r\n      destructorSignature,\r\n      rawDestructor\r\n    ) {\r\n      tupleRegistrations[rawType] = {\r\n        name: readLatin1String(name),\r\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\r\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\r\n        elements: [],\r\n      };\r\n    }\r\n\r\n  \r\n  function __embind_register_value_array_element(\r\n      rawTupleType,\r\n      getterReturnType,\r\n      getterSignature,\r\n      getter,\r\n      getterContext,\r\n      setterArgumentType,\r\n      setterSignature,\r\n      setter,\r\n      setterContext\r\n    ) {\r\n      tupleRegistrations[rawTupleType].elements.push({\r\n        getterReturnType: getterReturnType,\r\n        getter: embind__requireFunction(getterSignature, getter),\r\n        getterContext: getterContext,\r\n        setterArgumentType: setterArgumentType,\r\n        setter: embind__requireFunction(setterSignature, setter),\r\n        setterContext: setterContext,\r\n      });\r\n    }\r\n\r\n  \r\n  \r\n  function __embind_register_value_object(\r\n      rawType,\r\n      name,\r\n      constructorSignature,\r\n      rawConstructor,\r\n      destructorSignature,\r\n      rawDestructor\r\n    ) {\r\n      structRegistrations[rawType] = {\r\n        name: readLatin1String(name),\r\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\r\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\r\n        fields: [],\r\n      };\r\n    }\r\n\r\n  \r\n  \r\n  function __embind_register_value_object_field(\r\n      structType,\r\n      fieldName,\r\n      getterReturnType,\r\n      getterSignature,\r\n      getter,\r\n      getterContext,\r\n      setterArgumentType,\r\n      setterSignature,\r\n      setter,\r\n      setterContext\r\n    ) {\r\n      structRegistrations[structType].fields.push({\r\n        fieldName: readLatin1String(fieldName),\r\n        getterReturnType: getterReturnType,\r\n        getter: embind__requireFunction(getterSignature, getter),\r\n        getterContext: getterContext,\r\n        setterArgumentType: setterArgumentType,\r\n        setter: embind__requireFunction(setterSignature, setter),\r\n        setterContext: setterContext,\r\n      });\r\n    }\r\n\r\n  \r\n  function __embind_register_void(rawType, name) {\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n          isVoid: true, // void return values can be optimized out sometimes\r\n          name: name,\r\n          'argPackAdvance': 0,\r\n          'fromWireType': function() {\r\n              return undefined;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n              // TODO: assert if anything else is given?\r\n              return undefined;\r\n          },\r\n      });\r\n    }\r\n\r\n  function _abort() {\r\n      abort('native code called abort()');\r\n    }\r\n\r\n  function _emscripten_memcpy_big(dest, src, num) {\r\n      HEAPU8.copyWithin(dest, src, src + num);\r\n    }\r\n\r\n  function getHeapMax() {\r\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\r\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\r\n      // for any code that deals with heap sizes, which would require special\r\n      // casing all heap size related code to treat 0 specially.\r\n      return 2147483648;\r\n    }\r\n  \r\n  function emscripten_realloc_buffer(size) {\r\n      var b = wasmMemory.buffer;\r\n      var pages = (size - b.byteLength + 65535) >>> 16;\r\n      try {\r\n        // round size grow request up to wasm page size (fixed 64KB per spec)\r\n        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size\r\n        updateMemoryViews();\r\n        return 1 /*success*/;\r\n      } catch(e) {\r\n        err(`emscripten_realloc_buffer: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);\r\n      }\r\n      // implicit 0 return to save code size (caller will cast \"undefined\" into 0\r\n      // anyhow)\r\n    }\r\n  function _emscripten_resize_heap(requestedSize) {\r\n      var oldSize = HEAPU8.length;\r\n      requestedSize = requestedSize >>> 0;\r\n      // With multithreaded builds, races can happen (another thread might increase the size\r\n      // in between), so return a failure, and let the caller retry.\r\n      assert(requestedSize > oldSize);\r\n  \r\n      // Memory resize rules:\r\n      // 1.  Always increase heap size to at least the requested size, rounded up\r\n      //     to next page multiple.\r\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\r\n      //     geometrically: increase the heap size according to\r\n      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\r\n      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\r\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\r\n      //     linearly: increase the heap size by at least\r\n      //     MEMORY_GROWTH_LINEAR_STEP bytes.\r\n      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\r\n      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\r\n      // 4.  If we were unable to allocate as much memory, it may be due to\r\n      //     over-eager decision to excessively reserve due to (3) above.\r\n      //     Hence if an allocation fails, cut down on the amount of excess\r\n      //     growth, in an attempt to succeed to perform a smaller allocation.\r\n  \r\n      // A limit is set for how much we can grow. We should not exceed that\r\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\r\n      var maxHeapSize = getHeapMax();\r\n      if (requestedSize > maxHeapSize) {\r\n        err(`Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);\r\n        return false;\r\n      }\r\n  \r\n      var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\r\n  \r\n      // Loop through potential heap size increases. If we attempt a too eager\r\n      // reservation that fails, cut down on the attempted size and reserve a\r\n      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\r\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\r\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\r\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\r\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\r\n  \r\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\r\n  \r\n        var replacement = emscripten_realloc_buffer(newSize);\r\n        if (replacement) {\r\n  \r\n          return true;\r\n        }\r\n      }\r\n      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);\r\n      return false;\r\n    }\r\n\r\n  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {\r\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n        return splitPathRe.exec(filename).slice(1);\r\n      },normalizeArray:(parts, allowAboveRoot) => {\r\n        // if the path tries to go above the root, `up` ends up > 0\r\n        var up = 0;\r\n        for (var i = parts.length - 1; i >= 0; i--) {\r\n          var last = parts[i];\r\n          if (last === '.') {\r\n            parts.splice(i, 1);\r\n          } else if (last === '..') {\r\n            parts.splice(i, 1);\r\n            up++;\r\n          } else if (up) {\r\n            parts.splice(i, 1);\r\n            up--;\r\n          }\r\n        }\r\n        // if the path is allowed to go above the root, restore leading ..s\r\n        if (allowAboveRoot) {\r\n          for (; up; up--) {\r\n            parts.unshift('..');\r\n          }\r\n        }\r\n        return parts;\r\n      },normalize:(path) => {\r\n        var isAbsolute = PATH.isAbs(path),\r\n            trailingSlash = path.substr(-1) === '/';\r\n        // Normalize the path\r\n        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');\r\n        if (!path && !isAbsolute) {\r\n          path = '.';\r\n        }\r\n        if (path && trailingSlash) {\r\n          path += '/';\r\n        }\r\n        return (isAbsolute ? '/' : '') + path;\r\n      },dirname:(path) => {\r\n        var result = PATH.splitPath(path),\r\n            root = result[0],\r\n            dir = result[1];\r\n        if (!root && !dir) {\r\n          // No dirname whatsoever\r\n          return '.';\r\n        }\r\n        if (dir) {\r\n          // It has a dirname, strip trailing slash\r\n          dir = dir.substr(0, dir.length - 1);\r\n        }\r\n        return root + dir;\r\n      },basename:(path) => {\r\n        // EMSCRIPTEN return '/'' for '/', not an empty string\r\n        if (path === '/') return '/';\r\n        path = PATH.normalize(path);\r\n        path = path.replace(/\\/$/, \"\");\r\n        var lastSlash = path.lastIndexOf('/');\r\n        if (lastSlash === -1) return path;\r\n        return path.substr(lastSlash+1);\r\n      },join:function() {\r\n        var paths = Array.prototype.slice.call(arguments);\r\n        return PATH.normalize(paths.join('/'));\r\n      },join2:(l, r) => {\r\n        return PATH.normalize(l + '/' + r);\r\n      }};\r\n  \r\n  function initRandomFill() {\r\n      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\r\n        // for modern web browsers\r\n        return (view) => crypto.getRandomValues(view);\r\n      } else\r\n      if (ENVIRONMENT_IS_NODE) {\r\n        // for nodejs with or without crypto support included\r\n        try {\r\n          var crypto_module = __webpack_require__(/*! crypto */ \"crypto\");\r\n          var randomFillSync = crypto_module['randomFillSync'];\r\n          if (randomFillSync) {\r\n            // nodejs with LTS crypto support\r\n            return (view) => crypto_module['randomFillSync'](view);\r\n          }\r\n          // very old nodejs with the original crypto API\r\n          var randomBytes = crypto_module['randomBytes'];\r\n          return (view) => (\r\n            view.set(randomBytes(view.byteLength)),\r\n            // Return the original view to match modern native implementations.\r\n            view\r\n          );\r\n        } catch (e) {\r\n          // nodejs doesn't have crypto support\r\n        }\r\n      }\r\n      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\r\n      abort(\"no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\r\n    }\r\n  function randomFill(view) {\r\n      // Lazily init on the first invocation.\r\n      return (randomFill = initRandomFill())(view);\r\n    }\r\n  \r\n  \r\n  \r\n  var PATH_FS = {resolve:function() {\r\n        var resolvedPath = '',\r\n          resolvedAbsolute = false;\r\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n          var path = (i >= 0) ? arguments[i] : FS.cwd();\r\n          // Skip empty and invalid entries\r\n          if (typeof path != 'string') {\r\n            throw new TypeError('Arguments to path.resolve must be strings');\r\n          } else if (!path) {\r\n            return ''; // an invalid portion invalidates the whole thing\r\n          }\r\n          resolvedPath = path + '/' + resolvedPath;\r\n          resolvedAbsolute = PATH.isAbs(path);\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');\r\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n      },relative:(from, to) => {\r\n        from = PATH_FS.resolve(from).substr(1);\r\n        to = PATH_FS.resolve(to).substr(1);\r\n        function trim(arr) {\r\n          var start = 0;\r\n          for (; start < arr.length; start++) {\r\n            if (arr[start] !== '') break;\r\n          }\r\n          var end = arr.length - 1;\r\n          for (; end >= 0; end--) {\r\n            if (arr[end] !== '') break;\r\n          }\r\n          if (start > end) return [];\r\n          return arr.slice(start, end - start + 1);\r\n        }\r\n        var fromParts = trim(from.split('/'));\r\n        var toParts = trim(to.split('/'));\r\n        var length = Math.min(fromParts.length, toParts.length);\r\n        var samePartsLength = length;\r\n        for (var i = 0; i < length; i++) {\r\n          if (fromParts[i] !== toParts[i]) {\r\n            samePartsLength = i;\r\n            break;\r\n          }\r\n        }\r\n        var outputParts = [];\r\n        for (var i = samePartsLength; i < fromParts.length; i++) {\r\n          outputParts.push('..');\r\n        }\r\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n        return outputParts.join('/');\r\n      }};\r\n  \r\n  \r\n  \r\n  /** @type {function(string, boolean=, number=)} */\r\n  function intArrayFromString(stringy, dontAddNull, length) {\r\n    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\r\n    var u8array = new Array(len);\r\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n    if (dontAddNull) u8array.length = numBytesWritten;\r\n    return u8array;\r\n  }\r\n  \r\n  var TTY = {ttys:[],init:function () {\r\n        // https://github.com/emscripten-core/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\r\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\r\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\r\n        //   // with text files until FS.init can be refactored.\r\n        //   process.stdin.setEncoding('utf8');\r\n        // }\r\n      },shutdown:function() {\r\n        // https://github.com/emscripten-core/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\r\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\r\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\r\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\r\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\r\n        //   process.stdin.pause();\r\n        // }\r\n      },register:function(dev, ops) {\r\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\r\n        FS.registerDevice(dev, TTY.stream_ops);\r\n      },stream_ops:{open:function(stream) {\r\n          var tty = TTY.ttys[stream.node.rdev];\r\n          if (!tty) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          stream.tty = tty;\r\n          stream.seekable = false;\r\n        },close:function(stream) {\r\n          // flush any pending line data\r\n          stream.tty.ops.fsync(stream.tty);\r\n        },fsync:function(stream) {\r\n          stream.tty.ops.fsync(stream.tty);\r\n        },read:function(stream, buffer, offset, length, pos /* ignored */) {\r\n          if (!stream.tty || !stream.tty.ops.get_char) {\r\n            throw new FS.ErrnoError(60);\r\n          }\r\n          var bytesRead = 0;\r\n          for (var i = 0; i < length; i++) {\r\n            var result;\r\n            try {\r\n              result = stream.tty.ops.get_char(stream.tty);\r\n            } catch (e) {\r\n              throw new FS.ErrnoError(29);\r\n            }\r\n            if (result === undefined && bytesRead === 0) {\r\n              throw new FS.ErrnoError(6);\r\n            }\r\n            if (result === null || result === undefined) break;\r\n            bytesRead++;\r\n            buffer[offset+i] = result;\r\n          }\r\n          if (bytesRead) {\r\n            stream.node.timestamp = Date.now();\r\n          }\r\n          return bytesRead;\r\n        },write:function(stream, buffer, offset, length, pos) {\r\n          if (!stream.tty || !stream.tty.ops.put_char) {\r\n            throw new FS.ErrnoError(60);\r\n          }\r\n          try {\r\n            for (var i = 0; i < length; i++) {\r\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\r\n            }\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n          if (length) {\r\n            stream.node.timestamp = Date.now();\r\n          }\r\n          return i;\r\n        }},default_tty_ops:{get_char:function(tty) {\r\n          if (!tty.input.length) {\r\n            var result = null;\r\n            if (ENVIRONMENT_IS_NODE) {\r\n              // we will read data by chunks of BUFSIZE\r\n              var BUFSIZE = 256;\r\n              var buf = Buffer.alloc(BUFSIZE);\r\n              var bytesRead = 0;\r\n  \r\n              try {\r\n                bytesRead = fs.readSync(process.stdin.fd, buf, 0, BUFSIZE, -1);\r\n              } catch(e) {\r\n                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,\r\n                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.\r\n                if (e.toString().includes('EOF')) bytesRead = 0;\r\n                else throw e;\r\n              }\r\n  \r\n              if (bytesRead > 0) {\r\n                result = buf.slice(0, bytesRead).toString('utf-8');\r\n              } else {\r\n                result = null;\r\n              }\r\n            } else\r\n            if (typeof window != 'undefined' &&\r\n              typeof window.prompt == 'function') {\r\n              // Browser.\r\n              result = window.prompt('Input: ');  // returns null on cancel\r\n              if (result !== null) {\r\n                result += '\\n';\r\n              }\r\n            } else if (typeof readline == 'function') {\r\n              // Command line.\r\n              result = readline();\r\n              if (result !== null) {\r\n                result += '\\n';\r\n              }\r\n            }\r\n            if (!result) {\r\n              return null;\r\n            }\r\n            tty.input = intArrayFromString(result, true);\r\n          }\r\n          return tty.input.shift();\r\n        },put_char:function(tty, val) {\r\n          if (val === null || val === 10) {\r\n            out(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\r\n          }\r\n        },fsync:function(tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            out(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          }\r\n        }},default_tty1_ops:{put_char:function(tty, val) {\r\n          if (val === null || val === 10) {\r\n            err(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val);\r\n          }\r\n        },fsync:function(tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            err(UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          }\r\n        }}};\r\n  \r\n  \r\n  function zeroMemory(address, size) {\r\n      HEAPU8.fill(0, address, address + size);\r\n      return address;\r\n    }\r\n  \r\n  function alignMemory(size, alignment) {\r\n      assert(alignment, \"alignment argument is required\");\r\n      return Math.ceil(size / alignment) * alignment;\r\n    }\r\n  function mmapAlloc(size) {\r\n      abort('internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported');\r\n    }\r\n  var MEMFS = {ops_table:null,mount:function(mount) {\r\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\r\n      },createNode:function(parent, name, mode, dev) {\r\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n          // no supported\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (!MEMFS.ops_table) {\r\n          MEMFS.ops_table = {\r\n            dir: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr,\r\n                lookup: MEMFS.node_ops.lookup,\r\n                mknod: MEMFS.node_ops.mknod,\r\n                rename: MEMFS.node_ops.rename,\r\n                unlink: MEMFS.node_ops.unlink,\r\n                rmdir: MEMFS.node_ops.rmdir,\r\n                readdir: MEMFS.node_ops.readdir,\r\n                symlink: MEMFS.node_ops.symlink\r\n              },\r\n              stream: {\r\n                llseek: MEMFS.stream_ops.llseek\r\n              }\r\n            },\r\n            file: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr\r\n              },\r\n              stream: {\r\n                llseek: MEMFS.stream_ops.llseek,\r\n                read: MEMFS.stream_ops.read,\r\n                write: MEMFS.stream_ops.write,\r\n                allocate: MEMFS.stream_ops.allocate,\r\n                mmap: MEMFS.stream_ops.mmap,\r\n                msync: MEMFS.stream_ops.msync\r\n              }\r\n            },\r\n            link: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr,\r\n                readlink: MEMFS.node_ops.readlink\r\n              },\r\n              stream: {}\r\n            },\r\n            chrdev: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr\r\n              },\r\n              stream: FS.chrdev_stream_ops\r\n            }\r\n          };\r\n        }\r\n        var node = FS.createNode(parent, name, mode, dev);\r\n        if (FS.isDir(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.dir.node;\r\n          node.stream_ops = MEMFS.ops_table.dir.stream;\r\n          node.contents = {};\r\n        } else if (FS.isFile(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.file.node;\r\n          node.stream_ops = MEMFS.ops_table.file.stream;\r\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\r\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\r\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\r\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\r\n          node.contents = null; \r\n        } else if (FS.isLink(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.link.node;\r\n          node.stream_ops = MEMFS.ops_table.link.stream;\r\n        } else if (FS.isChrdev(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.chrdev.node;\r\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\r\n        }\r\n        node.timestamp = Date.now();\r\n        // add the new node to the parent\r\n        if (parent) {\r\n          parent.contents[name] = node;\r\n          parent.timestamp = node.timestamp;\r\n        }\r\n        return node;\r\n      },getFileDataAsTypedArray:function(node) {\r\n        if (!node.contents) return new Uint8Array(0);\r\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\r\n        return new Uint8Array(node.contents);\r\n      },expandFileStorage:function(node, newCapacity) {\r\n        var prevCapacity = node.contents ? node.contents.length : 0;\r\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\r\n        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\r\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\r\n        // avoid overshooting the allocation cap by a very large margin.\r\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);\r\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\r\n        var oldContents = node.contents;\r\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\r\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\r\n      },resizeFileStorage:function(node, newSize) {\r\n        if (node.usedBytes == newSize) return;\r\n        if (newSize == 0) {\r\n          node.contents = null; // Fully decommit when requesting a resize to zero.\r\n          node.usedBytes = 0;\r\n        } else {\r\n          var oldContents = node.contents;\r\n          node.contents = new Uint8Array(newSize); // Allocate new storage.\r\n          if (oldContents) {\r\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\r\n          }\r\n          node.usedBytes = newSize;\r\n        }\r\n      },node_ops:{getattr:function(node) {\r\n          var attr = {};\r\n          // device numbers reuse inode numbers.\r\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n          attr.ino = node.id;\r\n          attr.mode = node.mode;\r\n          attr.nlink = 1;\r\n          attr.uid = 0;\r\n          attr.gid = 0;\r\n          attr.rdev = node.rdev;\r\n          if (FS.isDir(node.mode)) {\r\n            attr.size = 4096;\r\n          } else if (FS.isFile(node.mode)) {\r\n            attr.size = node.usedBytes;\r\n          } else if (FS.isLink(node.mode)) {\r\n            attr.size = node.link.length;\r\n          } else {\r\n            attr.size = 0;\r\n          }\r\n          attr.atime = new Date(node.timestamp);\r\n          attr.mtime = new Date(node.timestamp);\r\n          attr.ctime = new Date(node.timestamp);\r\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\r\n          //       but this is not required by the standard.\r\n          attr.blksize = 4096;\r\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\r\n          return attr;\r\n        },setattr:function(node, attr) {\r\n          if (attr.mode !== undefined) {\r\n            node.mode = attr.mode;\r\n          }\r\n          if (attr.timestamp !== undefined) {\r\n            node.timestamp = attr.timestamp;\r\n          }\r\n          if (attr.size !== undefined) {\r\n            MEMFS.resizeFileStorage(node, attr.size);\r\n          }\r\n        },lookup:function(parent, name) {\r\n          throw FS.genericErrors[44];\r\n        },mknod:function(parent, name, mode, dev) {\r\n          return MEMFS.createNode(parent, name, mode, dev);\r\n        },rename:function(old_node, new_dir, new_name) {\r\n          // if we're overwriting a directory at new_name, make sure it's empty.\r\n          if (FS.isDir(old_node.mode)) {\r\n            var new_node;\r\n            try {\r\n              new_node = FS.lookupNode(new_dir, new_name);\r\n            } catch (e) {\r\n            }\r\n            if (new_node) {\r\n              for (var i in new_node.contents) {\r\n                throw new FS.ErrnoError(55);\r\n              }\r\n            }\r\n          }\r\n          // do the internal rewiring\r\n          delete old_node.parent.contents[old_node.name];\r\n          old_node.parent.timestamp = Date.now()\r\n          old_node.name = new_name;\r\n          new_dir.contents[new_name] = old_node;\r\n          new_dir.timestamp = old_node.parent.timestamp;\r\n          old_node.parent = new_dir;\r\n        },unlink:function(parent, name) {\r\n          delete parent.contents[name];\r\n          parent.timestamp = Date.now();\r\n        },rmdir:function(parent, name) {\r\n          var node = FS.lookupNode(parent, name);\r\n          for (var i in node.contents) {\r\n            throw new FS.ErrnoError(55);\r\n          }\r\n          delete parent.contents[name];\r\n          parent.timestamp = Date.now();\r\n        },readdir:function(node) {\r\n          var entries = ['.', '..'];\r\n          for (var key in node.contents) {\r\n            if (!node.contents.hasOwnProperty(key)) {\r\n              continue;\r\n            }\r\n            entries.push(key);\r\n          }\r\n          return entries;\r\n        },symlink:function(parent, newname, oldpath) {\r\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\r\n          node.link = oldpath;\r\n          return node;\r\n        },readlink:function(node) {\r\n          if (!FS.isLink(node.mode)) {\r\n            throw new FS.ErrnoError(28);\r\n          }\r\n          return node.link;\r\n        }},stream_ops:{read:function(stream, buffer, offset, length, position) {\r\n          var contents = stream.node.contents;\r\n          if (position >= stream.node.usedBytes) return 0;\r\n          var size = Math.min(stream.node.usedBytes - position, length);\r\n          assert(size >= 0);\r\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\r\n            buffer.set(contents.subarray(position, position + size), offset);\r\n          } else {\r\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\r\n          }\r\n          return size;\r\n        },write:function(stream, buffer, offset, length, position, canOwn) {\r\n          // The data buffer should be a typed array view\r\n          assert(!(buffer instanceof ArrayBuffer));\r\n          // If the buffer is located in main memory (HEAP), and if\r\n          // memory can grow, we can't hold on to references of the\r\n          // memory buffer, as they may get invalidated. That means we\r\n          // need to do copy its contents.\r\n          if (buffer.buffer === HEAP8.buffer) {\r\n            canOwn = false;\r\n          }\r\n  \r\n          if (!length) return 0;\r\n          var node = stream.node;\r\n          node.timestamp = Date.now();\r\n  \r\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\r\n            if (canOwn) {\r\n              assert(position === 0, 'canOwn must imply no weird position inside the file');\r\n              node.contents = buffer.subarray(offset, offset + length);\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\r\n              node.contents = buffer.slice(offset, offset + length);\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\r\n              node.contents.set(buffer.subarray(offset, offset + length), position);\r\n              return length;\r\n            }\r\n          }\r\n  \r\n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\r\n          MEMFS.expandFileStorage(node, position+length);\r\n          if (node.contents.subarray && buffer.subarray) {\r\n            // Use typed array write which is available.\r\n            node.contents.set(buffer.subarray(offset, offset + length), position);\r\n          } else {\r\n            for (var i = 0; i < length; i++) {\r\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\r\n            }\r\n          }\r\n          node.usedBytes = Math.max(node.usedBytes, position + length);\r\n          return length;\r\n        },llseek:function(stream, offset, whence) {\r\n          var position = offset;\r\n          if (whence === 1) {\r\n            position += stream.position;\r\n          } else if (whence === 2) {\r\n            if (FS.isFile(stream.node.mode)) {\r\n              position += stream.node.usedBytes;\r\n            }\r\n          }\r\n          if (position < 0) {\r\n            throw new FS.ErrnoError(28);\r\n          }\r\n          return position;\r\n        },allocate:function(stream, offset, length) {\r\n          MEMFS.expandFileStorage(stream.node, offset + length);\r\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\r\n        },mmap:function(stream, length, position, prot, flags) {\r\n          if (!FS.isFile(stream.node.mode)) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          var ptr;\r\n          var allocated;\r\n          var contents = stream.node.contents;\r\n          // Only make a new copy when MAP_PRIVATE is specified.\r\n          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {\r\n            // We can't emulate MAP_SHARED when the file is not backed by the\r\n            // buffer we're mapping to (e.g. the HEAP buffer).\r\n            allocated = false;\r\n            ptr = contents.byteOffset;\r\n          } else {\r\n            // Try to avoid unnecessary slices.\r\n            if (position > 0 || position + length < contents.length) {\r\n              if (contents.subarray) {\r\n                contents = contents.subarray(position, position + length);\r\n              } else {\r\n                contents = Array.prototype.slice.call(contents, position, position + length);\r\n              }\r\n            }\r\n            allocated = true;\r\n            ptr = mmapAlloc(length);\r\n            if (!ptr) {\r\n              throw new FS.ErrnoError(48);\r\n            }\r\n            HEAP8.set(contents, ptr);\r\n          }\r\n          return { ptr: ptr, allocated: allocated };\r\n        },msync:function(stream, buffer, offset, length, mmapFlags) {\r\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\r\n          // should we check if bytesWritten and length are the same?\r\n          return 0;\r\n        }}};\r\n  \r\n  /** @param {boolean=} noRunDep */\r\n  function asyncLoad(url, onload, onerror, noRunDep) {\r\n      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';\r\n      readAsync(url, (arrayBuffer) => {\r\n        assert(arrayBuffer, `Loading data file \"${url}\" failed (no arrayBuffer).`);\r\n        onload(new Uint8Array(arrayBuffer));\r\n        if (dep) removeRunDependency(dep);\r\n      }, (event) => {\r\n        if (onerror) {\r\n          onerror();\r\n        } else {\r\n          throw `Loading data file \"${url}\" failed.`;\r\n        }\r\n      });\r\n      if (dep) addRunDependency(dep);\r\n    }\r\n  \r\n  var preloadPlugins = Module['preloadPlugins'] || [];\r\n  function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {\r\n      // Ensure plugins are ready.\r\n      if (typeof Browser != 'undefined') Browser.init();\r\n  \r\n      var handled = false;\r\n      preloadPlugins.forEach(function(plugin) {\r\n        if (handled) return;\r\n        if (plugin['canHandle'](fullname)) {\r\n          plugin['handle'](byteArray, fullname, finish, onerror);\r\n          handled = true;\r\n        }\r\n      });\r\n      return handled;\r\n    }\r\n  function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\r\n      // TODO we should allow people to just pass in a complete filename instead\r\n      // of parent and name being that we just join them anyways\r\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\r\n      var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname\r\n      function processData(byteArray) {\r\n        function finish(byteArray) {\r\n          if (preFinish) preFinish();\r\n          if (!dontCreateFile) {\r\n            FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\r\n          }\r\n          if (onload) onload();\r\n          removeRunDependency(dep);\r\n        }\r\n        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\r\n          if (onerror) onerror();\r\n          removeRunDependency(dep);\r\n        })) {\r\n          return;\r\n        }\r\n        finish(byteArray);\r\n      }\r\n      addRunDependency(dep);\r\n      if (typeof url == 'string') {\r\n        asyncLoad(url, (byteArray) => processData(byteArray), onerror);\r\n      } else {\r\n        processData(url);\r\n      }\r\n    }\r\n  \r\n  function FS_modeStringToFlags(str) {\r\n      var flagModes = {\r\n        'r': 0,\r\n        'r+': 2,\r\n        'w': 512 | 64 | 1,\r\n        'w+': 512 | 64 | 2,\r\n        'a': 1024 | 64 | 1,\r\n        'a+': 1024 | 64 | 2,\r\n      };\r\n      var flags = flagModes[str];\r\n      if (typeof flags == 'undefined') {\r\n        throw new Error(`Unknown file open mode: ${str}`);\r\n      }\r\n      return flags;\r\n    }\r\n  \r\n  function FS_getMode(canRead, canWrite) {\r\n      var mode = 0;\r\n      if (canRead) mode |= 292 | 73;\r\n      if (canWrite) mode |= 146;\r\n      return mode;\r\n    }\r\n  \r\n  \r\n  \r\n  \r\n  var ERRNO_MESSAGES = {0:\"Success\",1:\"Arg list too long\",2:\"Permission denied\",3:\"Address already in use\",4:\"Address not available\",5:\"Address family not supported by protocol family\",6:\"No more processes\",7:\"Socket already connected\",8:\"Bad file number\",9:\"Trying to read unreadable message\",10:\"Mount device busy\",11:\"Operation canceled\",12:\"No children\",13:\"Connection aborted\",14:\"Connection refused\",15:\"Connection reset by peer\",16:\"File locking deadlock error\",17:\"Destination address required\",18:\"Math arg out of domain of func\",19:\"Quota exceeded\",20:\"File exists\",21:\"Bad address\",22:\"File too large\",23:\"Host is unreachable\",24:\"Identifier removed\",25:\"Illegal byte sequence\",26:\"Connection already in progress\",27:\"Interrupted system call\",28:\"Invalid argument\",29:\"I/O error\",30:\"Socket is already connected\",31:\"Is a directory\",32:\"Too many symbolic links\",33:\"Too many open files\",34:\"Too many links\",35:\"Message too long\",36:\"Multihop attempted\",37:\"File or path name too long\",38:\"Network interface is not configured\",39:\"Connection reset by network\",40:\"Network is unreachable\",41:\"Too many open files in system\",42:\"No buffer space available\",43:\"No such device\",44:\"No such file or directory\",45:\"Exec format error\",46:\"No record locks available\",47:\"The link has been severed\",48:\"Not enough core\",49:\"No message of desired type\",50:\"Protocol not available\",51:\"No space left on device\",52:\"Function not implemented\",53:\"Socket is not connected\",54:\"Not a directory\",55:\"Directory not empty\",56:\"State not recoverable\",57:\"Socket operation on non-socket\",59:\"Not a typewriter\",60:\"No such device or address\",61:\"Value too large for defined data type\",62:\"Previous owner died\",63:\"Not super-user\",64:\"Broken pipe\",65:\"Protocol error\",66:\"Unknown protocol\",67:\"Protocol wrong type for socket\",68:\"Math result not representable\",69:\"Read only file system\",70:\"Illegal seek\",71:\"No such process\",72:\"Stale file handle\",73:\"Connection timed out\",74:\"Text file busy\",75:\"Cross-device link\",100:\"Device not a stream\",101:\"Bad font file fmt\",102:\"Invalid slot\",103:\"Invalid request code\",104:\"No anode\",105:\"Block device required\",106:\"Channel number out of range\",107:\"Level 3 halted\",108:\"Level 3 reset\",109:\"Link number out of range\",110:\"Protocol driver not attached\",111:\"No CSI structure available\",112:\"Level 2 halted\",113:\"Invalid exchange\",114:\"Invalid request descriptor\",115:\"Exchange full\",116:\"No data (for no delay io)\",117:\"Timer expired\",118:\"Out of streams resources\",119:\"Machine is not on the network\",120:\"Package not installed\",121:\"The object is remote\",122:\"Advertise error\",123:\"Srmount error\",124:\"Communication error on send\",125:\"Cross mount point (not really error)\",126:\"Given log. name not unique\",127:\"f.d. invalid for this operation\",128:\"Remote address changed\",129:\"Can   access a needed shared lib\",130:\"Accessing a corrupted shared lib\",131:\".lib section in a.out corrupted\",132:\"Attempting to link in too many libs\",133:\"Attempting to exec a shared library\",135:\"Streams pipe error\",136:\"Too many users\",137:\"Socket type not supported\",138:\"Not supported\",139:\"Protocol family not supported\",140:\"Can't send after socket shutdown\",141:\"Too many references\",142:\"Host is down\",148:\"No medium (in tape drive)\",156:\"Level 2 not synchronized\"};\r\n  \r\n  var ERRNO_CODES = {};\r\n  \r\n  function demangle(func) {\r\n      warnOnce('warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling');\r\n      return func;\r\n    }\r\n  function demangleAll(text) {\r\n      var regex =\r\n        /\\b_Z[\\w\\d_]+/g;\r\n      return text.replace(regex,\r\n        function(x) {\r\n          var y = demangle(x);\r\n          return x === y ? x : (y + ' [' + x + ']');\r\n        });\r\n    }\r\n  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {\r\n        path = PATH_FS.resolve(path);\r\n  \r\n        if (!path) return { path: '', node: null };\r\n  \r\n        var defaults = {\r\n          follow_mount: true,\r\n          recurse_count: 0\r\n        };\r\n        opts = Object.assign(defaults, opts)\r\n  \r\n        if (opts.recurse_count > 8) {  // max recursive lookup of 8\r\n          throw new FS.ErrnoError(32);\r\n        }\r\n  \r\n        // split the absolute path\r\n        var parts = path.split('/').filter((p) => !!p);\r\n  \r\n        // start at the root\r\n        var current = FS.root;\r\n        var current_path = '/';\r\n  \r\n        for (var i = 0; i < parts.length; i++) {\r\n          var islast = (i === parts.length-1);\r\n          if (islast && opts.parent) {\r\n            // stop resolving\r\n            break;\r\n          }\r\n  \r\n          current = FS.lookupNode(current, parts[i]);\r\n          current_path = PATH.join2(current_path, parts[i]);\r\n  \r\n          // jump to the mount's root node if this is a mountpoint\r\n          if (FS.isMountpoint(current)) {\r\n            if (!islast || (islast && opts.follow_mount)) {\r\n              current = current.mounted.root;\r\n            }\r\n          }\r\n  \r\n          // by default, lookupPath will not follow a symlink if it is the final path component.\r\n          // setting opts.follow = true will override this behavior.\r\n          if (!islast || opts.follow) {\r\n            var count = 0;\r\n            while (FS.isLink(current.mode)) {\r\n              var link = FS.readlink(current_path);\r\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\r\n  \r\n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\r\n              current = lookup.node;\r\n  \r\n              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\r\n                throw new FS.ErrnoError(32);\r\n              }\r\n            }\r\n          }\r\n        }\r\n  \r\n        return { path: current_path, node: current };\r\n      },getPath:(node) => {\r\n        var path;\r\n        while (true) {\r\n          if (FS.isRoot(node)) {\r\n            var mount = node.mount.mountpoint;\r\n            if (!path) return mount;\r\n            return mount[mount.length-1] !== '/' ? `${mount}/${path}` : mount + path;\r\n          }\r\n          path = path ? `${node.name}/${path}` : node.name;\r\n          node = node.parent;\r\n        }\r\n      },hashName:(parentid, name) => {\r\n        var hash = 0;\r\n  \r\n        for (var i = 0; i < name.length; i++) {\r\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\r\n        }\r\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\r\n      },hashAddNode:(node) => {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        node.name_next = FS.nameTable[hash];\r\n        FS.nameTable[hash] = node;\r\n      },hashRemoveNode:(node) => {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        if (FS.nameTable[hash] === node) {\r\n          FS.nameTable[hash] = node.name_next;\r\n        } else {\r\n          var current = FS.nameTable[hash];\r\n          while (current) {\r\n            if (current.name_next === node) {\r\n              current.name_next = node.name_next;\r\n              break;\r\n            }\r\n            current = current.name_next;\r\n          }\r\n        }\r\n      },lookupNode:(parent, name) => {\r\n        var errCode = FS.mayLookup(parent);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode, parent);\r\n        }\r\n        var hash = FS.hashName(parent.id, name);\r\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n          var nodeName = node.name;\r\n          if (node.parent.id === parent.id && nodeName === name) {\r\n            return node;\r\n          }\r\n        }\r\n        // if we failed to find it in the cache, call into the VFS\r\n        return FS.lookup(parent, name);\r\n      },createNode:(parent, name, mode, rdev) => {\r\n        assert(typeof parent == 'object')\r\n        var node = new FS.FSNode(parent, name, mode, rdev);\r\n  \r\n        FS.hashAddNode(node);\r\n  \r\n        return node;\r\n      },destroyNode:(node) => {\r\n        FS.hashRemoveNode(node);\r\n      },isRoot:(node) => {\r\n        return node === node.parent;\r\n      },isMountpoint:(node) => {\r\n        return !!node.mounted;\r\n      },isFile:(mode) => {\r\n        return (mode & 61440) === 32768;\r\n      },isDir:(mode) => {\r\n        return (mode & 61440) === 16384;\r\n      },isLink:(mode) => {\r\n        return (mode & 61440) === 40960;\r\n      },isChrdev:(mode) => {\r\n        return (mode & 61440) === 8192;\r\n      },isBlkdev:(mode) => {\r\n        return (mode & 61440) === 24576;\r\n      },isFIFO:(mode) => {\r\n        return (mode & 61440) === 4096;\r\n      },isSocket:(mode) => {\r\n        return (mode & 49152) === 49152;\r\n      },flagsToPermissionString:(flag) => {\r\n        var perms = ['r', 'w', 'rw'][flag & 3];\r\n        if ((flag & 512)) {\r\n          perms += 'w';\r\n        }\r\n        return perms;\r\n      },nodePermissions:(node, perms) => {\r\n        if (FS.ignorePermissions) {\r\n          return 0;\r\n        }\r\n        // return 0 if any user, group or owner bits are set.\r\n        if (perms.includes('r') && !(node.mode & 292)) {\r\n          return 2;\r\n        } else if (perms.includes('w') && !(node.mode & 146)) {\r\n          return 2;\r\n        } else if (perms.includes('x') && !(node.mode & 73)) {\r\n          return 2;\r\n        }\r\n        return 0;\r\n      },mayLookup:(dir) => {\r\n        var errCode = FS.nodePermissions(dir, 'x');\r\n        if (errCode) return errCode;\r\n        if (!dir.node_ops.lookup) return 2;\r\n        return 0;\r\n      },mayCreate:(dir, name) => {\r\n        try {\r\n          var node = FS.lookupNode(dir, name);\r\n          return 20;\r\n        } catch (e) {\r\n        }\r\n        return FS.nodePermissions(dir, 'wx');\r\n      },mayDelete:(dir, name, isdir) => {\r\n        var node;\r\n        try {\r\n          node = FS.lookupNode(dir, name);\r\n        } catch (e) {\r\n          return e.errno;\r\n        }\r\n        var errCode = FS.nodePermissions(dir, 'wx');\r\n        if (errCode) {\r\n          return errCode;\r\n        }\r\n        if (isdir) {\r\n          if (!FS.isDir(node.mode)) {\r\n            return 54;\r\n          }\r\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n            return 10;\r\n          }\r\n        } else {\r\n          if (FS.isDir(node.mode)) {\r\n            return 31;\r\n          }\r\n        }\r\n        return 0;\r\n      },mayOpen:(node, flags) => {\r\n        if (!node) {\r\n          return 44;\r\n        }\r\n        if (FS.isLink(node.mode)) {\r\n          return 32;\r\n        } else if (FS.isDir(node.mode)) {\r\n          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\r\n              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\r\n            return 31;\r\n          }\r\n        }\r\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\r\n      },MAX_OPEN_FDS:4096,nextfd:() => {\r\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\r\n          if (!FS.streams[fd]) {\r\n            return fd;\r\n          }\r\n        }\r\n        throw new FS.ErrnoError(33);\r\n      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd = -1) => {\r\n        if (!FS.FSStream) {\r\n          FS.FSStream = /** @constructor */ function() {\r\n            this.shared = { };\r\n          };\r\n          FS.FSStream.prototype = {};\r\n          Object.defineProperties(FS.FSStream.prototype, {\r\n            object: {\r\n              /** @this {FS.FSStream} */\r\n              get: function() { return this.node; },\r\n              /** @this {FS.FSStream} */\r\n              set: function(val) { this.node = val; }\r\n            },\r\n            isRead: {\r\n              /** @this {FS.FSStream} */\r\n              get: function() { return (this.flags & 2097155) !== 1; }\r\n            },\r\n            isWrite: {\r\n              /** @this {FS.FSStream} */\r\n              get: function() { return (this.flags & 2097155) !== 0; }\r\n            },\r\n            isAppend: {\r\n              /** @this {FS.FSStream} */\r\n              get: function() { return (this.flags & 1024); }\r\n            },\r\n            flags: {\r\n              /** @this {FS.FSStream} */\r\n              get: function() { return this.shared.flags; },\r\n              /** @this {FS.FSStream} */\r\n              set: function(val) { this.shared.flags = val; },\r\n            },\r\n            position : {\r\n              /** @this {FS.FSStream} */\r\n              get: function() { return this.shared.position; },\r\n              /** @this {FS.FSStream} */\r\n              set: function(val) { this.shared.position = val; },\r\n            },\r\n          });\r\n        }\r\n        // clone it, so we can return an instance of FSStream\r\n        stream = Object.assign(new FS.FSStream(), stream);\r\n        if (fd == -1) {\r\n          fd = FS.nextfd();\r\n        }\r\n        stream.fd = fd;\r\n        FS.streams[fd] = stream;\r\n        return stream;\r\n      },closeStream:(fd) => {\r\n        FS.streams[fd] = null;\r\n      },chrdev_stream_ops:{open:(stream) => {\r\n          var device = FS.getDevice(stream.node.rdev);\r\n          // override node's stream ops with the device's\r\n          stream.stream_ops = device.stream_ops;\r\n          // forward the open call\r\n          if (stream.stream_ops.open) {\r\n            stream.stream_ops.open(stream);\r\n          }\r\n        },llseek:() => {\r\n          throw new FS.ErrnoError(70);\r\n        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {\r\n        FS.devices[dev] = { stream_ops: ops };\r\n      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {\r\n        var mounts = [];\r\n        var check = [mount];\r\n  \r\n        while (check.length) {\r\n          var m = check.pop();\r\n  \r\n          mounts.push(m);\r\n  \r\n          check.push.apply(check, m.mounts);\r\n        }\r\n  \r\n        return mounts;\r\n      },syncfs:(populate, callback) => {\r\n        if (typeof populate == 'function') {\r\n          callback = populate;\r\n          populate = false;\r\n        }\r\n  \r\n        FS.syncFSRequests++;\r\n  \r\n        if (FS.syncFSRequests > 1) {\r\n          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);\r\n        }\r\n  \r\n        var mounts = FS.getMounts(FS.root.mount);\r\n        var completed = 0;\r\n  \r\n        function doCallback(errCode) {\r\n          assert(FS.syncFSRequests > 0);\r\n          FS.syncFSRequests--;\r\n          return callback(errCode);\r\n        }\r\n  \r\n        function done(errCode) {\r\n          if (errCode) {\r\n            if (!done.errored) {\r\n              done.errored = true;\r\n              return doCallback(errCode);\r\n            }\r\n            return;\r\n          }\r\n          if (++completed >= mounts.length) {\r\n            doCallback(null);\r\n          }\r\n        };\r\n  \r\n        // sync all mounts\r\n        mounts.forEach((mount) => {\r\n          if (!mount.type.syncfs) {\r\n            return done(null);\r\n          }\r\n          mount.type.syncfs(mount, populate, done);\r\n        });\r\n      },mount:(type, opts, mountpoint) => {\r\n        if (typeof type == 'string') {\r\n          // The filesystem was not included, and instead we have an error\r\n          // message stored in the variable.\r\n          throw type;\r\n        }\r\n        var root = mountpoint === '/';\r\n        var pseudo = !mountpoint;\r\n        var node;\r\n  \r\n        if (root && FS.root) {\r\n          throw new FS.ErrnoError(10);\r\n        } else if (!root && !pseudo) {\r\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n          mountpoint = lookup.path;  // use the absolute path\r\n          node = lookup.node;\r\n  \r\n          if (FS.isMountpoint(node)) {\r\n            throw new FS.ErrnoError(10);\r\n          }\r\n  \r\n          if (!FS.isDir(node.mode)) {\r\n            throw new FS.ErrnoError(54);\r\n          }\r\n        }\r\n  \r\n        var mount = {\r\n          type: type,\r\n          opts: opts,\r\n          mountpoint: mountpoint,\r\n          mounts: []\r\n        };\r\n  \r\n        // create a root node for the fs\r\n        var mountRoot = type.mount(mount);\r\n        mountRoot.mount = mount;\r\n        mount.root = mountRoot;\r\n  \r\n        if (root) {\r\n          FS.root = mountRoot;\r\n        } else if (node) {\r\n          // set as a mountpoint\r\n          node.mounted = mount;\r\n  \r\n          // add the new mount to the current mount's children\r\n          if (node.mount) {\r\n            node.mount.mounts.push(mount);\r\n          }\r\n        }\r\n  \r\n        return mountRoot;\r\n      },unmount:(mountpoint) => {\r\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n        if (!FS.isMountpoint(lookup.node)) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n  \r\n        // destroy the nodes for this mount, and all its child mounts\r\n        var node = lookup.node;\r\n        var mount = node.mounted;\r\n        var mounts = FS.getMounts(mount);\r\n  \r\n        Object.keys(FS.nameTable).forEach((hash) => {\r\n          var current = FS.nameTable[hash];\r\n  \r\n          while (current) {\r\n            var next = current.name_next;\r\n  \r\n            if (mounts.includes(current.mount)) {\r\n              FS.destroyNode(current);\r\n            }\r\n  \r\n            current = next;\r\n          }\r\n        });\r\n  \r\n        // no longer a mountpoint\r\n        node.mounted = null;\r\n  \r\n        // remove this mount from the child mounts\r\n        var idx = node.mount.mounts.indexOf(mount);\r\n        assert(idx !== -1);\r\n        node.mount.mounts.splice(idx, 1);\r\n      },lookup:(parent, name) => {\r\n        return parent.node_ops.lookup(parent, name);\r\n      },mknod:(path, mode, dev) => {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        if (!name || name === '.' || name === '..') {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var errCode = FS.mayCreate(parent, name);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.mknod) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return parent.node_ops.mknod(parent, name, mode, dev);\r\n      },create:(path, mode) => {\r\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\r\n        mode &= 4095;\r\n        mode |= 32768;\r\n        return FS.mknod(path, mode, 0);\r\n      },mkdir:(path, mode) => {\r\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\r\n        mode &= 511 | 512;\r\n        mode |= 16384;\r\n        return FS.mknod(path, mode, 0);\r\n      },mkdirTree:(path, mode) => {\r\n        var dirs = path.split('/');\r\n        var d = '';\r\n        for (var i = 0; i < dirs.length; ++i) {\r\n          if (!dirs[i]) continue;\r\n          d += '/' + dirs[i];\r\n          try {\r\n            FS.mkdir(d, mode);\r\n          } catch(e) {\r\n            if (e.errno != 20) throw e;\r\n          }\r\n        }\r\n      },mkdev:(path, mode, dev) => {\r\n        if (typeof dev == 'undefined') {\r\n          dev = mode;\r\n          mode = 438 /* 0666 */;\r\n        }\r\n        mode |= 8192;\r\n        return FS.mknod(path, mode, dev);\r\n      },symlink:(oldpath, newpath) => {\r\n        if (!PATH_FS.resolve(oldpath)) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var lookup = FS.lookupPath(newpath, { parent: true });\r\n        var parent = lookup.node;\r\n        if (!parent) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var newname = PATH.basename(newpath);\r\n        var errCode = FS.mayCreate(parent, newname);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.symlink) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return parent.node_ops.symlink(parent, newname, oldpath);\r\n      },rename:(old_path, new_path) => {\r\n        var old_dirname = PATH.dirname(old_path);\r\n        var new_dirname = PATH.dirname(new_path);\r\n        var old_name = PATH.basename(old_path);\r\n        var new_name = PATH.basename(new_path);\r\n        // parents must exist\r\n        var lookup, old_dir, new_dir;\r\n  \r\n        // let the errors from non existant directories percolate up\r\n        lookup = FS.lookupPath(old_path, { parent: true });\r\n        old_dir = lookup.node;\r\n        lookup = FS.lookupPath(new_path, { parent: true });\r\n        new_dir = lookup.node;\r\n  \r\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\r\n        // need to be part of the same mount\r\n        if (old_dir.mount !== new_dir.mount) {\r\n          throw new FS.ErrnoError(75);\r\n        }\r\n        // source must exist\r\n        var old_node = FS.lookupNode(old_dir, old_name);\r\n        // old path should not be an ancestor of the new path\r\n        var relative = PATH_FS.relative(old_path, new_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        // new path should not be an ancestor of the old path\r\n        relative = PATH_FS.relative(new_path, old_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(55);\r\n        }\r\n        // see if the new path already exists\r\n        var new_node;\r\n        try {\r\n          new_node = FS.lookupNode(new_dir, new_name);\r\n        } catch (e) {\r\n          // not fatal\r\n        }\r\n        // early out if nothing needs to change\r\n        if (old_node === new_node) {\r\n          return;\r\n        }\r\n        // we'll need to delete the old entry\r\n        var isdir = FS.isDir(old_node.mode);\r\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        // need delete permissions if we'll be overwriting.\r\n        // need create permissions if new doesn't already exist.\r\n        errCode = new_node ?\r\n          FS.mayDelete(new_dir, new_name, isdir) :\r\n          FS.mayCreate(new_dir, new_name);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!old_dir.node_ops.rename) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        // if we are going to change the parent, check write permissions\r\n        if (new_dir !== old_dir) {\r\n          errCode = FS.nodePermissions(old_dir, 'w');\r\n          if (errCode) {\r\n            throw new FS.ErrnoError(errCode);\r\n          }\r\n        }\r\n        // remove the node from the lookup hash\r\n        FS.hashRemoveNode(old_node);\r\n        // do the underlying fs rename\r\n        try {\r\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          // add the node back to the hash (in case node_ops.rename\r\n          // changed its name)\r\n          FS.hashAddNode(old_node);\r\n        }\r\n      },rmdir:(path) => {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var errCode = FS.mayDelete(parent, name, true);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.rmdir) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        parent.node_ops.rmdir(parent, name);\r\n        FS.destroyNode(node);\r\n      },readdir:(path) => {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        if (!node.node_ops.readdir) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        return node.node_ops.readdir(node);\r\n      },unlink:(path) => {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        if (!parent) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var errCode = FS.mayDelete(parent, name, false);\r\n        if (errCode) {\r\n          // According to POSIX, we should map EISDIR to EPERM, but\r\n          // we instead do what Linux does (and we must, as we use\r\n          // the musl linux libc).\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.unlink) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        parent.node_ops.unlink(parent, name);\r\n        FS.destroyNode(node);\r\n      },readlink:(path) => {\r\n        var lookup = FS.lookupPath(path);\r\n        var link = lookup.node;\r\n        if (!link) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!link.node_ops.readlink) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\r\n      },stat:(path, dontFollow) => {\r\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n        var node = lookup.node;\r\n        if (!node) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!node.node_ops.getattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return node.node_ops.getattr(node);\r\n      },lstat:(path) => {\r\n        return FS.stat(path, true);\r\n      },chmod:(path, mode, dontFollow) => {\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          mode: (mode & 4095) | (node.mode & ~4095),\r\n          timestamp: Date.now()\r\n        });\r\n      },lchmod:(path, mode) => {\r\n        FS.chmod(path, mode, true);\r\n      },fchmod:(fd, mode) => {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        FS.chmod(stream.node, mode);\r\n      },chown:(path, uid, gid, dontFollow) => {\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          timestamp: Date.now()\r\n          // we ignore the uid / gid for now\r\n        });\r\n      },lchown:(path, uid, gid) => {\r\n        FS.chown(path, uid, gid, true);\r\n      },fchown:(fd, uid, gid) => {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        FS.chown(stream.node, uid, gid);\r\n      },truncate:(path, len) => {\r\n        if (len < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: true });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!FS.isFile(node.mode)) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var errCode = FS.nodePermissions(node, 'w');\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          size: len,\r\n          timestamp: Date.now()\r\n        });\r\n      },ftruncate:(fd, len) => {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        FS.truncate(stream.node, len);\r\n      },utime:(path, atime, mtime) => {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        node.node_ops.setattr(node, {\r\n          timestamp: Math.max(atime, mtime)\r\n        });\r\n      },open:(path, flags, mode) => {\r\n        if (path === \"\") {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\r\n        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;\r\n        if ((flags & 64)) {\r\n          mode = (mode & 4095) | 32768;\r\n        } else {\r\n          mode = 0;\r\n        }\r\n        var node;\r\n        if (typeof path == 'object') {\r\n          node = path;\r\n        } else {\r\n          path = PATH.normalize(path);\r\n          try {\r\n            var lookup = FS.lookupPath(path, {\r\n              follow: !(flags & 131072)\r\n            });\r\n            node = lookup.node;\r\n          } catch (e) {\r\n            // ignore\r\n          }\r\n        }\r\n        // perhaps we need to create the node\r\n        var created = false;\r\n        if ((flags & 64)) {\r\n          if (node) {\r\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\r\n            if ((flags & 128)) {\r\n              throw new FS.ErrnoError(20);\r\n            }\r\n          } else {\r\n            // node doesn't exist, try to create it\r\n            node = FS.mknod(path, mode, 0);\r\n            created = true;\r\n          }\r\n        }\r\n        if (!node) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        // can't truncate a device\r\n        if (FS.isChrdev(node.mode)) {\r\n          flags &= ~512;\r\n        }\r\n        // if asked only for a directory, then this must be one\r\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        // check permissions, if this is not a file we just created now (it is ok to\r\n        // create and write to a file with read-only permissions; it is read-only\r\n        // for later use)\r\n        if (!created) {\r\n          var errCode = FS.mayOpen(node, flags);\r\n          if (errCode) {\r\n            throw new FS.ErrnoError(errCode);\r\n          }\r\n        }\r\n        // do truncation if necessary\r\n        if ((flags & 512) && !created) {\r\n          FS.truncate(node, 0);\r\n        }\r\n        // we've already handled these, don't pass down to the underlying vfs\r\n        flags &= ~(128 | 512 | 131072);\r\n  \r\n        // register the stream with the filesystem\r\n        var stream = FS.createStream({\r\n          node: node,\r\n          path: FS.getPath(node),  // we want the absolute path to the node\r\n          flags: flags,\r\n          seekable: true,\r\n          position: 0,\r\n          stream_ops: node.stream_ops,\r\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\r\n          ungotten: [],\r\n          error: false\r\n        });\r\n        // call the new stream's open function\r\n        if (stream.stream_ops.open) {\r\n          stream.stream_ops.open(stream);\r\n        }\r\n        if (Module['logReadFiles'] && !(flags & 1)) {\r\n          if (!FS.readFiles) FS.readFiles = {};\r\n          if (!(path in FS.readFiles)) {\r\n            FS.readFiles[path] = 1;\r\n          }\r\n        }\r\n        return stream;\r\n      },close:(stream) => {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (stream.getdents) stream.getdents = null; // free readdir state\r\n        try {\r\n          if (stream.stream_ops.close) {\r\n            stream.stream_ops.close(stream);\r\n          }\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          FS.closeStream(stream.fd);\r\n        }\r\n        stream.fd = null;\r\n      },isClosed:(stream) => {\r\n        return stream.fd === null;\r\n      },llseek:(stream, offset, whence) => {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (!stream.seekable || !stream.stream_ops.llseek) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        if (whence != 0 && whence != 1 && whence != 2) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n        stream.ungotten = [];\r\n        return stream.position;\r\n      },read:(stream, buffer, offset, length, position) => {\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!stream.stream_ops.read) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var seeking = typeof position != 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\r\n        if (!seeking) stream.position += bytesRead;\r\n        return bytesRead;\r\n      },write:(stream, buffer, offset, length, position, canOwn) => {\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!stream.stream_ops.write) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (stream.seekable && stream.flags & 1024) {\r\n          // seek to the end before writing in append mode\r\n          FS.llseek(stream, 0, 2);\r\n        }\r\n        var seeking = typeof position != 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\r\n        if (!seeking) stream.position += bytesWritten;\r\n        return bytesWritten;\r\n      },allocate:(stream, offset, length) => {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (offset < 0 || length <= 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        if (!stream.stream_ops.allocate) {\r\n          throw new FS.ErrnoError(138);\r\n        }\r\n        stream.stream_ops.allocate(stream, offset, length);\r\n      },mmap:(stream, length, position, prot, flags) => {\r\n        // User requests writing to file (prot & PROT_WRITE != 0).\r\n        // Checking if we have permissions to write to the file unless\r\n        // MAP_PRIVATE flag is set. According to POSIX spec it is possible\r\n        // to write to file opened in read-only mode with MAP_PRIVATE flag,\r\n        // as all modifications will be visible only in the memory of\r\n        // the current process.\r\n        if ((prot & 2) !== 0\r\n            && (flags & 2) === 0\r\n            && (stream.flags & 2097155) !== 2) {\r\n          throw new FS.ErrnoError(2);\r\n        }\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(2);\r\n        }\r\n        if (!stream.stream_ops.mmap) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\r\n      },msync:(stream, buffer, offset, length, mmapFlags) => {\r\n        if (!stream.stream_ops.msync) {\r\n          return 0;\r\n        }\r\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\r\n      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {\r\n        if (!stream.stream_ops.ioctl) {\r\n          throw new FS.ErrnoError(59);\r\n        }\r\n        return stream.stream_ops.ioctl(stream, cmd, arg);\r\n      },readFile:(path, opts = {}) => {\r\n        opts.flags = opts.flags || 0;\r\n        opts.encoding = opts.encoding || 'binary';\r\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\r\n          throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\r\n        }\r\n        var ret;\r\n        var stream = FS.open(path, opts.flags);\r\n        var stat = FS.stat(path);\r\n        var length = stat.size;\r\n        var buf = new Uint8Array(length);\r\n        FS.read(stream, buf, 0, length, 0);\r\n        if (opts.encoding === 'utf8') {\r\n          ret = UTF8ArrayToString(buf, 0);\r\n        } else if (opts.encoding === 'binary') {\r\n          ret = buf;\r\n        }\r\n        FS.close(stream);\r\n        return ret;\r\n      },writeFile:(path, data, opts = {}) => {\r\n        opts.flags = opts.flags || 577;\r\n        var stream = FS.open(path, opts.flags, opts.mode);\r\n        if (typeof data == 'string') {\r\n          var buf = new Uint8Array(lengthBytesUTF8(data)+1);\r\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\r\n        } else if (ArrayBuffer.isView(data)) {\r\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\r\n        } else {\r\n          throw new Error('Unsupported data type');\r\n        }\r\n        FS.close(stream);\r\n      },cwd:() => FS.currentPath,chdir:(path) => {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        if (lookup.node === null) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!FS.isDir(lookup.node.mode)) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        var errCode = FS.nodePermissions(lookup.node, 'x');\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        FS.currentPath = lookup.path;\r\n      },createDefaultDirectories:() => {\r\n        FS.mkdir('/tmp');\r\n        FS.mkdir('/home');\r\n        FS.mkdir('/home/web_user');\r\n      },createDefaultDevices:() => {\r\n        // create /dev\r\n        FS.mkdir('/dev');\r\n        // setup /dev/null\r\n        FS.registerDevice(FS.makedev(1, 3), {\r\n          read: () => 0,\r\n          write: (stream, buffer, offset, length, pos) => length,\r\n        });\r\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\r\n        // setup /dev/tty and /dev/tty1\r\n        // stderr needs to print output using err() rather than out()\r\n        // so we register a second tty just for it.\r\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\r\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\r\n        // setup /dev/[u]random\r\n        // use a buffer to avoid overhead of individual crypto calls per byte\r\n        var randomBuffer = new Uint8Array(1024), randomLeft = 0;\r\n        var randomByte = () => {\r\n          if (randomLeft === 0) {\r\n            randomLeft = randomFill(randomBuffer).byteLength;\r\n          }\r\n          return randomBuffer[--randomLeft];\r\n        };\r\n        FS.createDevice('/dev', 'random', randomByte);\r\n        FS.createDevice('/dev', 'urandom', randomByte);\r\n        // we're not going to emulate the actual shm device,\r\n        // just create the tmp dirs that reside in it commonly\r\n        FS.mkdir('/dev/shm');\r\n        FS.mkdir('/dev/shm/tmp');\r\n      },createSpecialDirectories:() => {\r\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\r\n        // name of the stream for fd 6 (see test_unistd_ttyname)\r\n        FS.mkdir('/proc');\r\n        var proc_self = FS.mkdir('/proc/self');\r\n        FS.mkdir('/proc/self/fd');\r\n        FS.mount({\r\n          mount: () => {\r\n            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);\r\n            node.node_ops = {\r\n              lookup: (parent, name) => {\r\n                var fd = +name;\r\n                var stream = FS.getStream(fd);\r\n                if (!stream) throw new FS.ErrnoError(8);\r\n                var ret = {\r\n                  parent: null,\r\n                  mount: { mountpoint: 'fake' },\r\n                  node_ops: { readlink: () => stream.path },\r\n                };\r\n                ret.parent = ret; // make it look like a simple root node\r\n                return ret;\r\n              }\r\n            };\r\n            return node;\r\n          }\r\n        }, {}, '/proc/self/fd');\r\n      },createStandardStreams:() => {\r\n        // TODO deprecate the old functionality of a single\r\n        // input / output callback and that utilizes FS.createDevice\r\n        // and instead require a unique set of stream ops\r\n  \r\n        // by default, we symlink the standard streams to the\r\n        // default tty devices. however, if the standard streams\r\n        // have been overwritten we create a unique device for\r\n        // them instead.\r\n        if (Module['stdin']) {\r\n          FS.createDevice('/dev', 'stdin', Module['stdin']);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdin');\r\n        }\r\n        if (Module['stdout']) {\r\n          FS.createDevice('/dev', 'stdout', null, Module['stdout']);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdout');\r\n        }\r\n        if (Module['stderr']) {\r\n          FS.createDevice('/dev', 'stderr', null, Module['stderr']);\r\n        } else {\r\n          FS.symlink('/dev/tty1', '/dev/stderr');\r\n        }\r\n  \r\n        // open default streams for the stdin, stdout and stderr devices\r\n        var stdin = FS.open('/dev/stdin', 0);\r\n        var stdout = FS.open('/dev/stdout', 1);\r\n        var stderr = FS.open('/dev/stderr', 1);\r\n        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\r\n        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\r\n        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\r\n      },ensureErrnoError:() => {\r\n        if (FS.ErrnoError) return;\r\n        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {\r\n          // We set the `name` property to be able to identify `FS.ErrnoError`\r\n          // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\r\n          // - when using PROXYFS, an error can come from an underlying FS\r\n          // as different FS objects have their own FS.ErrnoError each,\r\n          // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\r\n          // we'll use the reliable test `err.name == \"ErrnoError\"` instead\r\n          this.name = 'ErrnoError';\r\n          this.node = node;\r\n          this.setErrno = /** @this{Object} */ function(errno) {\r\n            this.errno = errno;\r\n            for (var key in ERRNO_CODES) {\r\n              if (ERRNO_CODES[key] === errno) {\r\n                this.code = key;\r\n                break;\r\n              }\r\n            }\r\n          };\r\n          this.setErrno(errno);\r\n          this.message = ERRNO_MESSAGES[errno];\r\n  \r\n          // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack\r\n          // now ensures it shows what we want.\r\n          if (this.stack) {\r\n            // Define the stack property for Node.js 4, which otherwise errors on the next line.\r\n            Object.defineProperty(this, \"stack\", { value: (new Error).stack, writable: true });\r\n            this.stack = demangleAll(this.stack);\r\n          }\r\n        };\r\n        FS.ErrnoError.prototype = new Error();\r\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\r\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\r\n        [44].forEach((code) => {\r\n          FS.genericErrors[code] = new FS.ErrnoError(code);\r\n          FS.genericErrors[code].stack = '<generic error, no stack>';\r\n        });\r\n      },staticInit:() => {\r\n        FS.ensureErrnoError();\r\n  \r\n        FS.nameTable = new Array(4096);\r\n  \r\n        FS.mount(MEMFS, {}, '/');\r\n  \r\n        FS.createDefaultDirectories();\r\n        FS.createDefaultDevices();\r\n        FS.createSpecialDirectories();\r\n  \r\n        FS.filesystems = {\r\n          'MEMFS': MEMFS,\r\n        };\r\n      },init:(input, output, error) => {\r\n        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');\r\n        FS.init.initialized = true;\r\n  \r\n        FS.ensureErrnoError();\r\n  \r\n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\r\n        Module['stdin'] = input || Module['stdin'];\r\n        Module['stdout'] = output || Module['stdout'];\r\n        Module['stderr'] = error || Module['stderr'];\r\n  \r\n        FS.createStandardStreams();\r\n      },quit:() => {\r\n        FS.init.initialized = false;\r\n        // force-flush all streams, so we get musl std streams printed out\r\n        _fflush(0);\r\n        // close all of our streams\r\n        for (var i = 0; i < FS.streams.length; i++) {\r\n          var stream = FS.streams[i];\r\n          if (!stream) {\r\n            continue;\r\n          }\r\n          FS.close(stream);\r\n        }\r\n      },findObject:(path, dontResolveLastLink) => {\r\n        var ret = FS.analyzePath(path, dontResolveLastLink);\r\n        if (!ret.exists) {\r\n          return null;\r\n        }\r\n        return ret.object;\r\n      },analyzePath:(path, dontResolveLastLink) => {\r\n        // operate from within the context of the symlink's target\r\n        try {\r\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          path = lookup.path;\r\n        } catch (e) {\r\n        }\r\n        var ret = {\r\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\r\n          parentExists: false, parentPath: null, parentObject: null\r\n        };\r\n        try {\r\n          var lookup = FS.lookupPath(path, { parent: true });\r\n          ret.parentExists = true;\r\n          ret.parentPath = lookup.path;\r\n          ret.parentObject = lookup.node;\r\n          ret.name = PATH.basename(path);\r\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          ret.exists = true;\r\n          ret.path = lookup.path;\r\n          ret.object = lookup.node;\r\n          ret.name = lookup.node.name;\r\n          ret.isRoot = lookup.path === '/';\r\n        } catch (e) {\r\n          ret.error = e.errno;\r\n        };\r\n        return ret;\r\n      },createPath:(parent, path, canRead, canWrite) => {\r\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n        var parts = path.split('/').reverse();\r\n        while (parts.length) {\r\n          var part = parts.pop();\r\n          if (!part) continue;\r\n          var current = PATH.join2(parent, part);\r\n          try {\r\n            FS.mkdir(current);\r\n          } catch (e) {\r\n            // ignore EEXIST\r\n          }\r\n          parent = current;\r\n        }\r\n        return current;\r\n      },createFile:(parent, name, properties, canRead, canWrite) => {\r\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS_getMode(canRead, canWrite);\r\n        return FS.create(path, mode);\r\n      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {\r\n        var path = name;\r\n        if (parent) {\r\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n          path = name ? PATH.join2(parent, name) : parent;\r\n        }\r\n        var mode = FS_getMode(canRead, canWrite);\r\n        var node = FS.create(path, mode);\r\n        if (data) {\r\n          if (typeof data == 'string') {\r\n            var arr = new Array(data.length);\r\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\r\n            data = arr;\r\n          }\r\n          // make sure we can write to the file\r\n          FS.chmod(node, mode | 146);\r\n          var stream = FS.open(node, 577);\r\n          FS.write(stream, data, 0, data.length, 0, canOwn);\r\n          FS.close(stream);\r\n          FS.chmod(node, mode);\r\n        }\r\n        return node;\r\n      },createDevice:(parent, name, input, output) => {\r\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS_getMode(!!input, !!output);\r\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\r\n        var dev = FS.makedev(FS.createDevice.major++, 0);\r\n        // Create a fake device that a set of stream ops to emulate\r\n        // the old behavior.\r\n        FS.registerDevice(dev, {\r\n          open: (stream) => {\r\n            stream.seekable = false;\r\n          },\r\n          close: (stream) => {\r\n            // flush any pending line data\r\n            if (output && output.buffer && output.buffer.length) {\r\n              output(10);\r\n            }\r\n          },\r\n          read: (stream, buffer, offset, length, pos /* ignored */) => {\r\n            var bytesRead = 0;\r\n            for (var i = 0; i < length; i++) {\r\n              var result;\r\n              try {\r\n                result = input();\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(29);\r\n              }\r\n              if (result === undefined && bytesRead === 0) {\r\n                throw new FS.ErrnoError(6);\r\n              }\r\n              if (result === null || result === undefined) break;\r\n              bytesRead++;\r\n              buffer[offset+i] = result;\r\n            }\r\n            if (bytesRead) {\r\n              stream.node.timestamp = Date.now();\r\n            }\r\n            return bytesRead;\r\n          },\r\n          write: (stream, buffer, offset, length, pos) => {\r\n            for (var i = 0; i < length; i++) {\r\n              try {\r\n                output(buffer[offset+i]);\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(29);\r\n              }\r\n            }\r\n            if (length) {\r\n              stream.node.timestamp = Date.now();\r\n            }\r\n            return i;\r\n          }\r\n        });\r\n        return FS.mkdev(path, mode, dev);\r\n      },forceLoadFile:(obj) => {\r\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n        if (typeof XMLHttpRequest != 'undefined') {\r\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\r\n        } else if (read_) {\r\n          // Command-line.\r\n          try {\r\n            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\r\n            //          read() will try to parse UTF8.\r\n            obj.contents = intArrayFromString(read_(obj.url), true);\r\n            obj.usedBytes = obj.contents.length;\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n        } else {\r\n          throw new Error('Cannot load without read() or XMLHttpRequest.');\r\n        }\r\n      },createLazyFile:(parent, name, url, canRead, canWrite) => {\r\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\r\n        /** @constructor */\r\n        function LazyUint8Array() {\r\n          this.lengthKnown = false;\r\n          this.chunks = []; // Loaded chunks. Index is the chunk number\r\n        }\r\n        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {\r\n          if (idx > this.length-1 || idx < 0) {\r\n            return undefined;\r\n          }\r\n          var chunkOffset = idx % this.chunkSize;\r\n          var chunkNum = (idx / this.chunkSize)|0;\r\n          return this.getter(chunkNum)[chunkOffset];\r\n        };\r\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\r\n          this.getter = getter;\r\n        };\r\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\r\n          // Find length\r\n          var xhr = new XMLHttpRequest();\r\n          xhr.open('HEAD', url, false);\r\n          xhr.send(null);\r\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n          var header;\r\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\r\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\r\n  \r\n          var chunkSize = 1024*1024; // Chunk size in bytes\r\n  \r\n          if (!hasByteServing) chunkSize = datalength;\r\n  \r\n          // Function to get a range from the remote URL.\r\n          var doXHR = (from, to) => {\r\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\r\n            if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\r\n  \r\n            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.open('GET', url, false);\r\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n  \r\n            // Some hints to the browser that we want binary data.\r\n            xhr.responseType = 'arraybuffer';\r\n            if (xhr.overrideMimeType) {\r\n              xhr.overrideMimeType('text/plain; charset=x-user-defined');\r\n            }\r\n  \r\n            xhr.send(null);\r\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n            if (xhr.response !== undefined) {\r\n              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));\r\n            }\r\n            return intArrayFromString(xhr.responseText || '', true);\r\n          };\r\n          var lazyArray = this;\r\n          lazyArray.setDataGetter((chunkNum) => {\r\n            var start = chunkNum * chunkSize;\r\n            var end = (chunkNum+1) * chunkSize - 1; // including this byte\r\n            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\r\n            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\r\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\r\n            }\r\n            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');\r\n            return lazyArray.chunks[chunkNum];\r\n          });\r\n  \r\n          if (usesGzip || !datalength) {\r\n            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\r\n            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\r\n            datalength = this.getter(0).length;\r\n            chunkSize = datalength;\r\n            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\r\n          }\r\n  \r\n          this._length = datalength;\r\n          this._chunkSize = chunkSize;\r\n          this.lengthKnown = true;\r\n        };\r\n        if (typeof XMLHttpRequest != 'undefined') {\r\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\r\n          var lazyArray = new LazyUint8Array();\r\n          Object.defineProperties(lazyArray, {\r\n            length: {\r\n              get: /** @this{Object} */ function() {\r\n                if (!this.lengthKnown) {\r\n                  this.cacheLength();\r\n                }\r\n                return this._length;\r\n              }\r\n            },\r\n            chunkSize: {\r\n              get: /** @this{Object} */ function() {\r\n                if (!this.lengthKnown) {\r\n                  this.cacheLength();\r\n                }\r\n                return this._chunkSize;\r\n              }\r\n            }\r\n          });\r\n  \r\n          var properties = { isDevice: false, contents: lazyArray };\r\n        } else {\r\n          var properties = { isDevice: false, url: url };\r\n        }\r\n  \r\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n        // This is a total hack, but I want to get this lazy file code out of the\r\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\r\n        // be its own thin LAZYFS proxying calls to MEMFS.\r\n        if (properties.contents) {\r\n          node.contents = properties.contents;\r\n        } else if (properties.url) {\r\n          node.contents = null;\r\n          node.url = properties.url;\r\n        }\r\n        // Add a function that defers querying the file size until it is asked the first time.\r\n        Object.defineProperties(node, {\r\n          usedBytes: {\r\n            get: /** @this {FSNode} */ function() { return this.contents.length; }\r\n          }\r\n        });\r\n        // override each stream op with one that tries to force load the lazy file first\r\n        var stream_ops = {};\r\n        var keys = Object.keys(node.stream_ops);\r\n        keys.forEach((key) => {\r\n          var fn = node.stream_ops[key];\r\n          stream_ops[key] = function forceLoadLazyFile() {\r\n            FS.forceLoadFile(node);\r\n            return fn.apply(null, arguments);\r\n          };\r\n        });\r\n        function writeChunks(stream, buffer, offset, length, position) {\r\n          var contents = stream.node.contents;\r\n          if (position >= contents.length)\r\n            return 0;\r\n          var size = Math.min(contents.length - position, length);\r\n          assert(size >= 0);\r\n          if (contents.slice) { // normal array\r\n            for (var i = 0; i < size; i++) {\r\n              buffer[offset + i] = contents[position + i];\r\n            }\r\n          } else {\r\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\r\n              buffer[offset + i] = contents.get(position + i);\r\n            }\r\n          }\r\n          return size;\r\n        }\r\n        // use a custom read function\r\n        stream_ops.read = (stream, buffer, offset, length, position) => {\r\n          FS.forceLoadFile(node);\r\n          return writeChunks(stream, buffer, offset, length, position)\r\n        };\r\n        // use a custom mmap function\r\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\r\n          FS.forceLoadFile(node);\r\n          var ptr = mmapAlloc(length);\r\n          if (!ptr) {\r\n            throw new FS.ErrnoError(48);\r\n          }\r\n          writeChunks(stream, HEAP8, ptr, length, position);\r\n          return { ptr: ptr, allocated: true };\r\n        };\r\n        node.stream_ops = stream_ops;\r\n        return node;\r\n      },absolutePath:() => {\r\n        abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');\r\n      },createFolder:() => {\r\n        abort('FS.createFolder has been removed; use FS.mkdir instead');\r\n      },createLink:() => {\r\n        abort('FS.createLink has been removed; use FS.symlink instead');\r\n      },joinPath:() => {\r\n        abort('FS.joinPath has been removed; use PATH.join instead');\r\n      },mmapAlloc:() => {\r\n        abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');\r\n      },standardizePath:() => {\r\n        abort('FS.standardizePath has been removed; use PATH.normalize instead');\r\n      }};\r\n  \r\n  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {\r\n        if (PATH.isAbs(path)) {\r\n          return path;\r\n        }\r\n        // relative path\r\n        var dir;\r\n        if (dirfd === -100) {\r\n          dir = FS.cwd();\r\n        } else {\r\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\r\n          dir = dirstream.path;\r\n        }\r\n        if (path.length == 0) {\r\n          if (!allowEmpty) {\r\n            throw new FS.ErrnoError(44);;\r\n          }\r\n          return dir;\r\n        }\r\n        return PATH.join2(dir, path);\r\n      },doStat:function(func, path, buf) {\r\n        try {\r\n          var stat = func(path);\r\n        } catch (e) {\r\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\r\n            // an error occurred while trying to look up the path; we should just report ENOTDIR\r\n            return -54;\r\n          }\r\n          throw e;\r\n        }\r\n        HEAP32[((buf)>>2)] = stat.dev;\r\n        HEAP32[(((buf)+(8))>>2)] = stat.ino;\r\n        HEAP32[(((buf)+(12))>>2)] = stat.mode;\r\n        HEAPU32[(((buf)+(16))>>2)] = stat.nlink;\r\n        HEAP32[(((buf)+(20))>>2)] = stat.uid;\r\n        HEAP32[(((buf)+(24))>>2)] = stat.gid;\r\n        HEAP32[(((buf)+(28))>>2)] = stat.rdev;\r\n        HEAP64[(((buf)+(40))>>3)] = BigInt(stat.size);\r\n        HEAP32[(((buf)+(48))>>2)] = 4096;\r\n        HEAP32[(((buf)+(52))>>2)] = stat.blocks;\r\n        var atime = stat.atime.getTime();\r\n        var mtime = stat.mtime.getTime();\r\n        var ctime = stat.ctime.getTime();\r\n        HEAP64[(((buf)+(56))>>3)] = BigInt(Math.floor(atime / 1000));\r\n        HEAPU32[(((buf)+(64))>>2)] = (atime % 1000) * 1000;\r\n        HEAP64[(((buf)+(72))>>3)] = BigInt(Math.floor(mtime / 1000));\r\n        HEAPU32[(((buf)+(80))>>2)] = (mtime % 1000) * 1000;\r\n        HEAP64[(((buf)+(88))>>3)] = BigInt(Math.floor(ctime / 1000));\r\n        HEAPU32[(((buf)+(96))>>2)] = (ctime % 1000) * 1000;\r\n        HEAP64[(((buf)+(104))>>3)] = BigInt(stat.ino);\r\n        return 0;\r\n      },doMsync:function(addr, stream, len, flags, offset) {\r\n        if (!FS.isFile(stream.node.mode)) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        if (flags & 2) {\r\n          // MAP_PRIVATE calls need not to be synced back to underlying fs\r\n          return 0;\r\n        }\r\n        var buffer = HEAPU8.slice(addr, addr + len);\r\n        FS.msync(stream, buffer, offset, len, flags);\r\n      },varargs:undefined,get:function() {\r\n        assert(SYSCALLS.varargs != undefined);\r\n        SYSCALLS.varargs += 4;\r\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\r\n        return ret;\r\n      },getStr:function(ptr) {\r\n        var ret = UTF8ToString(ptr);\r\n        return ret;\r\n      },getStreamFromFD:function(fd) {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) throw new FS.ErrnoError(8);\r\n        return stream;\r\n      }};\r\n  function _fd_close(fd) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      FS.close(stream);\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  var MAX_INT53 = 9007199254740992;\r\n  \r\n  var MIN_INT53 = -9007199254740992;\r\n  function bigintToI53Checked(num) {\r\n      return (num < MIN_INT53 || num > MAX_INT53) ? NaN : Number(num);\r\n    }\r\n  \r\n  \r\n  \r\n  \r\n  function _fd_seek(fd, offset, whence, newOffset) {\r\n  try {\r\n  \r\n      offset = bigintToI53Checked(offset); if (isNaN(offset)) return 61;\r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      FS.llseek(stream, offset, whence);\r\n      HEAP64[((newOffset)>>3)] = BigInt(stream.position);\r\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  /** @param {number=} offset */\r\n  function doWritev(stream, iov, iovcnt, offset) {\r\n      var ret = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAPU32[((iov)>>2)];\r\n        var len = HEAPU32[(((iov)+(4))>>2)];\r\n        iov += 8;\r\n        var curr = FS.write(stream, HEAP8,ptr, len, offset);\r\n        if (curr < 0) return -1;\r\n        ret += curr;\r\n        if (typeof offset !== 'undefined') {\r\n          offset += curr;\r\n        }\r\n      }\r\n      return ret;\r\n    }\r\n  \r\n  function _fd_write(fd, iov, iovcnt, pnum) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      var num = doWritev(stream, iov, iovcnt);\r\n      HEAPU32[((pnum)>>2)] = num;\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n\r\nInternalError = Module['InternalError'] = extendError(Error, 'InternalError');;\r\nembind_init_charCodes();\r\nBindingError = Module['BindingError'] = extendError(Error, 'BindingError');;\r\ninit_emval();;\r\n\r\n  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {\r\n    if (!parent) {\r\n      parent = this;  // root node sets parent to itself\r\n    }\r\n    this.parent = parent;\r\n    this.mount = parent.mount;\r\n    this.mounted = null;\r\n    this.id = FS.nextInode++;\r\n    this.name = name;\r\n    this.mode = mode;\r\n    this.node_ops = {};\r\n    this.stream_ops = {};\r\n    this.rdev = rdev;\r\n  };\r\n  var readMode = 292/*292*/ | 73/*73*/;\r\n  var writeMode = 146/*146*/;\r\n  Object.defineProperties(FSNode.prototype, {\r\n   read: {\r\n    get: /** @this{FSNode} */function() {\r\n     return (this.mode & readMode) === readMode;\r\n    },\r\n    set: /** @this{FSNode} */function(val) {\r\n     val ? this.mode |= readMode : this.mode &= ~readMode;\r\n    }\r\n   },\r\n   write: {\r\n    get: /** @this{FSNode} */function() {\r\n     return (this.mode & writeMode) === writeMode;\r\n    },\r\n    set: /** @this{FSNode} */function(val) {\r\n     val ? this.mode |= writeMode : this.mode &= ~writeMode;\r\n    }\r\n   },\r\n   isFolder: {\r\n    get: /** @this{FSNode} */function() {\r\n     return FS.isDir(this.mode);\r\n    }\r\n   },\r\n   isDevice: {\r\n    get: /** @this{FSNode} */function() {\r\n     return FS.isChrdev(this.mode);\r\n    }\r\n   }\r\n  });\r\n  FS.FSNode = FSNode;\r\n  FS.createPreloadedFile = FS_createPreloadedFile;\r\n  FS.staticInit();Module[\"FS_createPath\"] = FS.createPath;Module[\"FS_createDataFile\"] = FS.createDataFile;Module[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;Module[\"FS_unlink\"] = FS.unlink;Module[\"FS_createLazyFile\"] = FS.createLazyFile;Module[\"FS_createDevice\"] = FS.createDevice;;\r\nERRNO_CODES = {\r\n      'EPERM': 63,\r\n      'ENOENT': 44,\r\n      'ESRCH': 71,\r\n      'EINTR': 27,\r\n      'EIO': 29,\r\n      'ENXIO': 60,\r\n      'E2BIG': 1,\r\n      'ENOEXEC': 45,\r\n      'EBADF': 8,\r\n      'ECHILD': 12,\r\n      'EAGAIN': 6,\r\n      'EWOULDBLOCK': 6,\r\n      'ENOMEM': 48,\r\n      'EACCES': 2,\r\n      'EFAULT': 21,\r\n      'ENOTBLK': 105,\r\n      'EBUSY': 10,\r\n      'EEXIST': 20,\r\n      'EXDEV': 75,\r\n      'ENODEV': 43,\r\n      'ENOTDIR': 54,\r\n      'EISDIR': 31,\r\n      'EINVAL': 28,\r\n      'ENFILE': 41,\r\n      'EMFILE': 33,\r\n      'ENOTTY': 59,\r\n      'ETXTBSY': 74,\r\n      'EFBIG': 22,\r\n      'ENOSPC': 51,\r\n      'ESPIPE': 70,\r\n      'EROFS': 69,\r\n      'EMLINK': 34,\r\n      'EPIPE': 64,\r\n      'EDOM': 18,\r\n      'ERANGE': 68,\r\n      'ENOMSG': 49,\r\n      'EIDRM': 24,\r\n      'ECHRNG': 106,\r\n      'EL2NSYNC': 156,\r\n      'EL3HLT': 107,\r\n      'EL3RST': 108,\r\n      'ELNRNG': 109,\r\n      'EUNATCH': 110,\r\n      'ENOCSI': 111,\r\n      'EL2HLT': 112,\r\n      'EDEADLK': 16,\r\n      'ENOLCK': 46,\r\n      'EBADE': 113,\r\n      'EBADR': 114,\r\n      'EXFULL': 115,\r\n      'ENOANO': 104,\r\n      'EBADRQC': 103,\r\n      'EBADSLT': 102,\r\n      'EDEADLOCK': 16,\r\n      'EBFONT': 101,\r\n      'ENOSTR': 100,\r\n      'ENODATA': 116,\r\n      'ETIME': 117,\r\n      'ENOSR': 118,\r\n      'ENONET': 119,\r\n      'ENOPKG': 120,\r\n      'EREMOTE': 121,\r\n      'ENOLINK': 47,\r\n      'EADV': 122,\r\n      'ESRMNT': 123,\r\n      'ECOMM': 124,\r\n      'EPROTO': 65,\r\n      'EMULTIHOP': 36,\r\n      'EDOTDOT': 125,\r\n      'EBADMSG': 9,\r\n      'ENOTUNIQ': 126,\r\n      'EBADFD': 127,\r\n      'EREMCHG': 128,\r\n      'ELIBACC': 129,\r\n      'ELIBBAD': 130,\r\n      'ELIBSCN': 131,\r\n      'ELIBMAX': 132,\r\n      'ELIBEXEC': 133,\r\n      'ENOSYS': 52,\r\n      'ENOTEMPTY': 55,\r\n      'ENAMETOOLONG': 37,\r\n      'ELOOP': 32,\r\n      'EOPNOTSUPP': 138,\r\n      'EPFNOSUPPORT': 139,\r\n      'ECONNRESET': 15,\r\n      'ENOBUFS': 42,\r\n      'EAFNOSUPPORT': 5,\r\n      'EPROTOTYPE': 67,\r\n      'ENOTSOCK': 57,\r\n      'ENOPROTOOPT': 50,\r\n      'ESHUTDOWN': 140,\r\n      'ECONNREFUSED': 14,\r\n      'EADDRINUSE': 3,\r\n      'ECONNABORTED': 13,\r\n      'ENETUNREACH': 40,\r\n      'ENETDOWN': 38,\r\n      'ETIMEDOUT': 73,\r\n      'EHOSTDOWN': 142,\r\n      'EHOSTUNREACH': 23,\r\n      'EINPROGRESS': 26,\r\n      'EALREADY': 7,\r\n      'EDESTADDRREQ': 17,\r\n      'EMSGSIZE': 35,\r\n      'EPROTONOSUPPORT': 66,\r\n      'ESOCKTNOSUPPORT': 137,\r\n      'EADDRNOTAVAIL': 4,\r\n      'ENETRESET': 39,\r\n      'EISCONN': 30,\r\n      'ENOTCONN': 53,\r\n      'ETOOMANYREFS': 141,\r\n      'EUSERS': 136,\r\n      'EDQUOT': 19,\r\n      'ESTALE': 72,\r\n      'ENOTSUP': 138,\r\n      'ENOMEDIUM': 148,\r\n      'EILSEQ': 25,\r\n      'EOVERFLOW': 61,\r\n      'ECANCELED': 11,\r\n      'ENOTRECOVERABLE': 56,\r\n      'EOWNERDEAD': 62,\r\n      'ESTRPIPE': 135,\r\n    };;\r\n// include: base64Utils.js\r\n// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149\r\n\r\n// This code was written by Tyler Akins and has been placed in the\r\n// public domain.  It would be nice if you left this header intact.\r\n// Base64 code from Tyler Akins -- http://rumkin.com\r\n\r\n/**\r\n * Decodes a base64 string.\r\n * @param {string} input The string to decode.\r\n */\r\nvar decodeBase64 = typeof atob == 'function' ? atob : function (input) {\r\n  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n\r\n  var output = '';\r\n  var chr1, chr2, chr3;\r\n  var enc1, enc2, enc3, enc4;\r\n  var i = 0;\r\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\r\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\r\n  do {\r\n    enc1 = keyStr.indexOf(input.charAt(i++));\r\n    enc2 = keyStr.indexOf(input.charAt(i++));\r\n    enc3 = keyStr.indexOf(input.charAt(i++));\r\n    enc4 = keyStr.indexOf(input.charAt(i++));\r\n\r\n    chr1 = (enc1 << 2) | (enc2 >> 4);\r\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\r\n    chr3 = ((enc3 & 3) << 6) | enc4;\r\n\r\n    output = output + String.fromCharCode(chr1);\r\n\r\n    if (enc3 !== 64) {\r\n      output = output + String.fromCharCode(chr2);\r\n    }\r\n    if (enc4 !== 64) {\r\n      output = output + String.fromCharCode(chr3);\r\n    }\r\n  } while (i < input.length);\r\n  return output;\r\n};\r\n\r\n// Converts a string of base64 into a byte array.\r\n// Throws error on invalid input.\r\nfunction intArrayFromBase64(s) {\r\n  if (typeof ENVIRONMENT_IS_NODE == 'boolean' && ENVIRONMENT_IS_NODE) {\r\n    var buf = Buffer.from(s, 'base64');\r\n    return new Uint8Array(buf['buffer'], buf['byteOffset'], buf['byteLength']);\r\n  }\r\n\r\n  try {\r\n    var decoded = decodeBase64(s);\r\n    var bytes = new Uint8Array(decoded.length);\r\n    for (var i = 0 ; i < decoded.length ; ++i) {\r\n      bytes[i] = decoded.charCodeAt(i);\r\n    }\r\n    return bytes;\r\n  } catch (_) {\r\n    throw new Error('Converting base64 string to bytes failed.');\r\n  }\r\n}\r\n\r\n// If filename is a base64 data URI, parses and returns data (Buffer on node,\r\n// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\r\nfunction tryParseAsDataURI(filename) {\r\n  if (!isDataURI(filename)) {\r\n    return;\r\n  }\r\n\r\n  return intArrayFromBase64(filename.slice(dataURIPrefix.length));\r\n}\r\n\r\n\r\n// end include: base64Utils.js\r\nfunction checkIncomingModuleAPI() {\r\n  ignoredModuleProp('fetchSettings');\r\n}\r\nvar wasmImports = {\r\n  \"__cxa_throw\": ___cxa_throw,\r\n  \"_embind_finalize_value_array\": __embind_finalize_value_array,\r\n  \"_embind_finalize_value_object\": __embind_finalize_value_object,\r\n  \"_embind_register_bigint\": __embind_register_bigint,\r\n  \"_embind_register_bool\": __embind_register_bool,\r\n  \"_embind_register_constant\": __embind_register_constant,\r\n  \"_embind_register_emval\": __embind_register_emval,\r\n  \"_embind_register_float\": __embind_register_float,\r\n  \"_embind_register_integer\": __embind_register_integer,\r\n  \"_embind_register_memory_view\": __embind_register_memory_view,\r\n  \"_embind_register_std_string\": __embind_register_std_string,\r\n  \"_embind_register_std_wstring\": __embind_register_std_wstring,\r\n  \"_embind_register_value_array\": __embind_register_value_array,\r\n  \"_embind_register_value_array_element\": __embind_register_value_array_element,\r\n  \"_embind_register_value_object\": __embind_register_value_object,\r\n  \"_embind_register_value_object_field\": __embind_register_value_object_field,\r\n  \"_embind_register_void\": __embind_register_void,\r\n  \"abort\": _abort,\r\n  \"emscripten_memcpy_big\": _emscripten_memcpy_big,\r\n  \"emscripten_resize_heap\": _emscripten_resize_heap,\r\n  \"fd_close\": _fd_close,\r\n  \"fd_seek\": _fd_seek,\r\n  \"fd_write\": _fd_write\r\n};\r\nvar asm = createWasm();\r\n/** @type {function(...*):?} */\r\nvar ___wasm_call_ctors = createExportWrapper(\"__wasm_call_ctors\");\r\n/** @type {function(...*):?} */\r\nvar _malloc = createExportWrapper(\"malloc\");\r\n/** @type {function(...*):?} */\r\nvar _free = createExportWrapper(\"free\");\r\n/** @type {function(...*):?} */\r\nvar ___getTypeName = createExportWrapper(\"__getTypeName\");\r\n/** @type {function(...*):?} */\r\nvar __embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = createExportWrapper(\"_embind_initialize_bindings\");\r\n/** @type {function(...*):?} */\r\nvar ___errno_location = createExportWrapper(\"__errno_location\");\r\n/** @type {function(...*):?} */\r\nvar _fflush = Module[\"_fflush\"] = createExportWrapper(\"fflush\");\r\n/** @type {function(...*):?} */\r\nvar _emscripten_stack_init = function() {\r\n  return (_emscripten_stack_init = Module[\"asm\"][\"emscripten_stack_init\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _emscripten_stack_get_free = function() {\r\n  return (_emscripten_stack_get_free = Module[\"asm\"][\"emscripten_stack_get_free\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _emscripten_stack_get_base = function() {\r\n  return (_emscripten_stack_get_base = Module[\"asm\"][\"emscripten_stack_get_base\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar _emscripten_stack_get_end = function() {\r\n  return (_emscripten_stack_get_end = Module[\"asm\"][\"emscripten_stack_get_end\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar stackSave = createExportWrapper(\"stackSave\");\r\n/** @type {function(...*):?} */\r\nvar stackRestore = createExportWrapper(\"stackRestore\");\r\n/** @type {function(...*):?} */\r\nvar stackAlloc = createExportWrapper(\"stackAlloc\");\r\n/** @type {function(...*):?} */\r\nvar _emscripten_stack_get_current = function() {\r\n  return (_emscripten_stack_get_current = Module[\"asm\"][\"emscripten_stack_get_current\"]).apply(null, arguments);\r\n};\r\n\r\n/** @type {function(...*):?} */\r\nvar ___cxa_is_pointer_type = createExportWrapper(\"__cxa_is_pointer_type\");\r\n\r\n\r\n// include: postamble.js\r\n// === Auto-generated postamble setup entry stuff ===\r\n\r\nModule[\"addRunDependency\"] = addRunDependency;\r\nModule[\"removeRunDependency\"] = removeRunDependency;\r\nModule[\"FS_createPath\"] = FS.createPath;\r\nModule[\"FS_createDataFile\"] = FS.createDataFile;\r\nModule[\"FS_createLazyFile\"] = FS.createLazyFile;\r\nModule[\"FS_createDevice\"] = FS.createDevice;\r\nModule[\"FS_unlink\"] = FS.unlink;\r\nModule[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\r\nvar missingLibrarySymbols = [\r\n  'exitJS',\r\n  'isLeapYear',\r\n  'ydayFromDate',\r\n  'arraySum',\r\n  'addDays',\r\n  'setErrNo',\r\n  'inetPton4',\r\n  'inetNtop4',\r\n  'inetPton6',\r\n  'inetNtop6',\r\n  'readSockaddr',\r\n  'writeSockaddr',\r\n  'getHostByName',\r\n  'traverseStack',\r\n  'getCallstack',\r\n  'emscriptenLog',\r\n  'convertPCtoSourceLocation',\r\n  'readEmAsmArgs',\r\n  'jstoi_q',\r\n  'jstoi_s',\r\n  'getExecutableName',\r\n  'listenOnce',\r\n  'autoResumeAudioContext',\r\n  'getDynCaller',\r\n  'dynCall',\r\n  'handleException',\r\n  'runtimeKeepalivePush',\r\n  'runtimeKeepalivePop',\r\n  'callUserCallback',\r\n  'maybeExit',\r\n  'safeSetTimeout',\r\n  'asmjsMangle',\r\n  'getNativeTypeSize',\r\n  'STACK_SIZE',\r\n  'STACK_ALIGN',\r\n  'POINTER_SIZE',\r\n  'ASSERTIONS',\r\n  'writeI53ToI64',\r\n  'writeI53ToI64Clamped',\r\n  'writeI53ToI64Signaling',\r\n  'writeI53ToU64Clamped',\r\n  'writeI53ToU64Signaling',\r\n  'readI53FromI64',\r\n  'readI53FromU64',\r\n  'convertI32PairToI53',\r\n  'convertI32PairToI53Checked',\r\n  'convertU32PairToI53',\r\n  'getCFunc',\r\n  'ccall',\r\n  'cwrap',\r\n  'uleb128Encode',\r\n  'sigToWasmTypes',\r\n  'generateFuncType',\r\n  'convertJsFunctionToWasm',\r\n  'getEmptyTableSlot',\r\n  'updateTableMap',\r\n  'getFunctionAddress',\r\n  'addFunction',\r\n  'removeFunction',\r\n  'reallyNegative',\r\n  'unSign',\r\n  'strLen',\r\n  'reSign',\r\n  'formatString',\r\n  'intArrayToString',\r\n  'AsciiToString',\r\n  'stringToAscii',\r\n  'stringToNewUTF8',\r\n  'stringToUTF8OnStack',\r\n  'writeArrayToMemory',\r\n  'registerKeyEventCallback',\r\n  'maybeCStringToJsString',\r\n  'findEventTarget',\r\n  'findCanvasEventTarget',\r\n  'getBoundingClientRect',\r\n  'fillMouseEventData',\r\n  'registerMouseEventCallback',\r\n  'registerWheelEventCallback',\r\n  'registerUiEventCallback',\r\n  'registerFocusEventCallback',\r\n  'fillDeviceOrientationEventData',\r\n  'registerDeviceOrientationEventCallback',\r\n  'fillDeviceMotionEventData',\r\n  'registerDeviceMotionEventCallback',\r\n  'screenOrientation',\r\n  'fillOrientationChangeEventData',\r\n  'registerOrientationChangeEventCallback',\r\n  'fillFullscreenChangeEventData',\r\n  'registerFullscreenChangeEventCallback',\r\n  'JSEvents_requestFullscreen',\r\n  'JSEvents_resizeCanvasForFullscreen',\r\n  'registerRestoreOldStyle',\r\n  'hideEverythingExceptGivenElement',\r\n  'restoreHiddenElements',\r\n  'setLetterbox',\r\n  'softFullscreenResizeWebGLRenderTarget',\r\n  'doRequestFullscreen',\r\n  'fillPointerlockChangeEventData',\r\n  'registerPointerlockChangeEventCallback',\r\n  'registerPointerlockErrorEventCallback',\r\n  'requestPointerLock',\r\n  'fillVisibilityChangeEventData',\r\n  'registerVisibilityChangeEventCallback',\r\n  'registerTouchEventCallback',\r\n  'fillGamepadEventData',\r\n  'registerGamepadEventCallback',\r\n  'registerBeforeUnloadEventCallback',\r\n  'fillBatteryEventData',\r\n  'battery',\r\n  'registerBatteryEventCallback',\r\n  'setCanvasElementSize',\r\n  'getCanvasElementSize',\r\n  'jsStackTrace',\r\n  'stackTrace',\r\n  'getEnvStrings',\r\n  'checkWasiClock',\r\n  'doReadv',\r\n  'wasiRightsToMuslOFlags',\r\n  'wasiOFlagsToMuslOFlags',\r\n  'createDyncallWrapper',\r\n  'setImmediateWrapped',\r\n  'clearImmediateWrapped',\r\n  'polyfillSetImmediate',\r\n  'getPromise',\r\n  'makePromise',\r\n  'idsToPromises',\r\n  'makePromiseCallback',\r\n  'setMainLoop',\r\n  'getSocketFromFD',\r\n  'getSocketAddress',\r\n  '_setNetworkCallback',\r\n  'heapObjectForWebGLType',\r\n  'heapAccessShiftForWebGLHeap',\r\n  'webgl_enable_ANGLE_instanced_arrays',\r\n  'webgl_enable_OES_vertex_array_object',\r\n  'webgl_enable_WEBGL_draw_buffers',\r\n  'webgl_enable_WEBGL_multi_draw',\r\n  'emscriptenWebGLGet',\r\n  'computeUnpackAlignedImageSize',\r\n  'colorChannelsInGlTextureFormat',\r\n  'emscriptenWebGLGetTexPixelData',\r\n  '__glGenObject',\r\n  'emscriptenWebGLGetUniform',\r\n  'webglGetUniformLocation',\r\n  'webglPrepareUniformLocationsBeforeFirstUse',\r\n  'webglGetLeftBracePos',\r\n  'emscriptenWebGLGetVertexAttrib',\r\n  '__glGetActiveAttribOrUniform',\r\n  'writeGLArray',\r\n  'registerWebGlEventCallback',\r\n  'runAndAbortIfError',\r\n  'SDL_unicode',\r\n  'SDL_ttfContext',\r\n  'SDL_audio',\r\n  'GLFW_Window',\r\n  'ALLOC_NORMAL',\r\n  'ALLOC_STACK',\r\n  'allocate',\r\n  'writeStringToMemory',\r\n  'writeAsciiToMemory',\r\n  'init_embind',\r\n  'throwUnboundTypeError',\r\n  'ensureOverloadTable',\r\n  'exposePublicSymbol',\r\n  'replacePublicSymbol',\r\n  'getBasestPointer',\r\n  'registerInheritedInstance',\r\n  'unregisterInheritedInstance',\r\n  'getInheritedInstance',\r\n  'getInheritedInstanceCount',\r\n  'getLiveInheritedInstances',\r\n  'getTypeName',\r\n  'heap32VectorToArray',\r\n  'requireRegisteredType',\r\n  'enumReadValueFromPointer',\r\n  'newFunc',\r\n  'craftInvokerFunction',\r\n  'genericPointerToWireType',\r\n  'constNoSmartPtrRawPointerToWireType',\r\n  'nonConstNoSmartPtrRawPointerToWireType',\r\n  'init_RegisteredPointer',\r\n  'RegisteredPointer',\r\n  'RegisteredPointer_getPointee',\r\n  'RegisteredPointer_destructor',\r\n  'RegisteredPointer_deleteObject',\r\n  'RegisteredPointer_fromWireType',\r\n  'runDestructor',\r\n  'releaseClassHandle',\r\n  'detachFinalizer',\r\n  'attachFinalizer',\r\n  'makeClassHandle',\r\n  'init_ClassHandle',\r\n  'ClassHandle',\r\n  'ClassHandle_isAliasOf',\r\n  'throwInstanceAlreadyDeleted',\r\n  'ClassHandle_clone',\r\n  'ClassHandle_delete',\r\n  'ClassHandle_isDeleted',\r\n  'ClassHandle_deleteLater',\r\n  'flushPendingDeletes',\r\n  'setDelayFunction',\r\n  'RegisteredClass',\r\n  'shallowCopyInternalPointer',\r\n  'downcastPointer',\r\n  'upcastPointer',\r\n  'validateThis',\r\n  'getStringOrSymbol',\r\n  'craftEmvalAllocator',\r\n  'emval_get_global',\r\n  'emval_lookupTypes',\r\n  'emval_allocateDestructors',\r\n  'emval_addMethodCaller',\r\n];\r\nmissingLibrarySymbols.forEach(missingLibrarySymbol)\r\n\r\nvar unexportedSymbols = [\r\n  'run',\r\n  'addOnPreRun',\r\n  'addOnInit',\r\n  'addOnPreMain',\r\n  'addOnExit',\r\n  'addOnPostRun',\r\n  'FS_createFolder',\r\n  'FS_createLink',\r\n  'out',\r\n  'err',\r\n  'callMain',\r\n  'abort',\r\n  'keepRuntimeAlive',\r\n  'wasmMemory',\r\n  'stackAlloc',\r\n  'stackSave',\r\n  'stackRestore',\r\n  'getTempRet0',\r\n  'setTempRet0',\r\n  'writeStackCookie',\r\n  'checkStackCookie',\r\n  'ptrToString',\r\n  'zeroMemory',\r\n  'getHeapMax',\r\n  'emscripten_realloc_buffer',\r\n  'ENV',\r\n  'MONTH_DAYS_REGULAR',\r\n  'MONTH_DAYS_LEAP',\r\n  'MONTH_DAYS_REGULAR_CUMULATIVE',\r\n  'MONTH_DAYS_LEAP_CUMULATIVE',\r\n  'ERRNO_CODES',\r\n  'ERRNO_MESSAGES',\r\n  'DNS',\r\n  'Protocols',\r\n  'Sockets',\r\n  'initRandomFill',\r\n  'randomFill',\r\n  'timers',\r\n  'warnOnce',\r\n  'UNWIND_CACHE',\r\n  'readEmAsmArgsArray',\r\n  'asyncLoad',\r\n  'alignMemory',\r\n  'mmapAlloc',\r\n  'HandleAllocator',\r\n  'MAX_INT53',\r\n  'MIN_INT53',\r\n  'bigintToI53Checked',\r\n  'freeTableIndexes',\r\n  'functionsInTableMap',\r\n  'setValue',\r\n  'getValue',\r\n  'PATH',\r\n  'PATH_FS',\r\n  'UTF8Decoder',\r\n  'UTF8ArrayToString',\r\n  'UTF8ToString',\r\n  'stringToUTF8Array',\r\n  'stringToUTF8',\r\n  'lengthBytesUTF8',\r\n  'intArrayFromString',\r\n  'UTF16Decoder',\r\n  'UTF16ToString',\r\n  'stringToUTF16',\r\n  'lengthBytesUTF16',\r\n  'UTF32ToString',\r\n  'stringToUTF32',\r\n  'lengthBytesUTF32',\r\n  'JSEvents',\r\n  'specialHTMLTargets',\r\n  'currentFullscreenStrategy',\r\n  'restoreOldWindowedStyle',\r\n  'demangle',\r\n  'demangleAll',\r\n  'ExitStatus',\r\n  'doWritev',\r\n  'dlopenMissingError',\r\n  'promiseMap',\r\n  'uncaughtExceptionCount',\r\n  'exceptionLast',\r\n  'exceptionCaught',\r\n  'ExceptionInfo',\r\n  'Browser',\r\n  'wget',\r\n  'SYSCALLS',\r\n  'preloadPlugins',\r\n  'FS_modeStringToFlags',\r\n  'FS_getMode',\r\n  'FS',\r\n  'MEMFS',\r\n  'TTY',\r\n  'PIPEFS',\r\n  'SOCKFS',\r\n  'tempFixedLengthArray',\r\n  'miniTempWebGLFloatBuffers',\r\n  'miniTempWebGLIntBuffers',\r\n  'GL',\r\n  'emscripten_webgl_power_preferences',\r\n  'AL',\r\n  'GLUT',\r\n  'EGL',\r\n  'GLEW',\r\n  'IDBStore',\r\n  'SDL',\r\n  'SDL_gfx',\r\n  'GLFW',\r\n  'allocateUTF8',\r\n  'allocateUTF8OnStack',\r\n  'InternalError',\r\n  'BindingError',\r\n  'UnboundTypeError',\r\n  'PureVirtualError',\r\n  'throwInternalError',\r\n  'throwBindingError',\r\n  'extendError',\r\n  'createNamedFunction',\r\n  'embindRepr',\r\n  'registeredInstances',\r\n  'registeredTypes',\r\n  'awaitingDependencies',\r\n  'typeDependencies',\r\n  'registeredPointers',\r\n  'registerType',\r\n  'whenDependentTypesAreResolved',\r\n  'embind_charCodes',\r\n  'embind_init_charCodes',\r\n  'readLatin1String',\r\n  'getShiftFromSize',\r\n  'integerReadValueFromPointer',\r\n  'floatReadValueFromPointer',\r\n  'simpleReadValueFromPointer',\r\n  'runDestructors',\r\n  'embind__requireFunction',\r\n  'tupleRegistrations',\r\n  'structRegistrations',\r\n  'finalizationRegistry',\r\n  'detachFinalizer_deps',\r\n  'deletionQueue',\r\n  'delayFunction',\r\n  'char_0',\r\n  'char_9',\r\n  'makeLegalFunctionName',\r\n  'emval_handles',\r\n  'emval_symbols',\r\n  'init_emval',\r\n  'count_emval_handles',\r\n  'Emval',\r\n  'emval_newers',\r\n  'emval_methodCallers',\r\n  'emval_registeredMethods',\r\n];\r\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\r\n\r\n\r\n\r\nvar calledRun;\r\n\r\ndependenciesFulfilled = function runCaller() {\r\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\r\n  if (!calledRun) run();\r\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\r\n};\r\n\r\nfunction stackCheckInit() {\r\n  // This is normally called automatically during __wasm_call_ctors but need to\r\n  // get these values before even running any of the ctors so we call it redundantly\r\n  // here.\r\n  _emscripten_stack_init();\r\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\r\n  writeStackCookie();\r\n}\r\n\r\nfunction run() {\r\n\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n    stackCheckInit();\r\n\r\n  preRun();\r\n\r\n  // a preRun added a dependency, run will be called later\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n  function doRun() {\r\n    // run may have just been called through dependencies being fulfilled just in this very frame,\r\n    // or while the async setStatus time below was happening\r\n    if (calledRun) return;\r\n    calledRun = true;\r\n    Module['calledRun'] = true;\r\n\r\n    if (ABORT) return;\r\n\r\n    initRuntime();\r\n\r\n    readyPromiseResolve(Module);\r\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\r\n\r\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\r\n\r\n    postRun();\r\n  }\r\n\r\n  if (Module['setStatus']) {\r\n    Module['setStatus']('Running...');\r\n    setTimeout(function() {\r\n      setTimeout(function() {\r\n        Module['setStatus']('');\r\n      }, 1);\r\n      doRun();\r\n    }, 1);\r\n  } else\r\n  {\r\n    doRun();\r\n  }\r\n  checkStackCookie();\r\n}\r\n\r\nfunction checkUnflushedContent() {\r\n  // Compiler settings do not allow exiting the runtime, so flushing\r\n  // the streams is not possible. but in ASSERTIONS mode we check\r\n  // if there was something to flush, and if so tell the user they\r\n  // should request that the runtime be exitable.\r\n  // Normally we would not even include flush() at all, but in ASSERTIONS\r\n  // builds we do so just for this check, and here we see if there is any\r\n  // content to flush, that is, we check if there would have been\r\n  // something a non-ASSERTIONS build would have not seen.\r\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\r\n  // mode (which has its own special function for this; otherwise, all\r\n  // the code is inside libc)\r\n  var oldOut = out;\r\n  var oldErr = err;\r\n  var has = false;\r\n  out = err = (x) => {\r\n    has = true;\r\n  }\r\n  try { // it doesn't matter if it fails\r\n    _fflush(0);\r\n    // also flush in the JS FS layer\r\n    ['stdout', 'stderr'].forEach(function(name) {\r\n      var info = FS.analyzePath('/dev/' + name);\r\n      if (!info) return;\r\n      var stream = info.object;\r\n      var rdev = stream.rdev;\r\n      var tty = TTY.ttys[rdev];\r\n      if (tty && tty.output && tty.output.length) {\r\n        has = true;\r\n      }\r\n    });\r\n  } catch(e) {}\r\n  out = oldOut;\r\n  err = oldErr;\r\n  if (has) {\r\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\r\n  }\r\n}\r\n\r\nif (Module['preInit']) {\r\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\r\n  while (Module['preInit'].length > 0) {\r\n    Module['preInit'].pop()();\r\n  }\r\n}\r\n\r\nrun();\r\n\r\n\r\n// end include: postamble.js\r\n\r\n\r\n  return Module.ready\r\n}\r\n\r\n);\r\n})();\r\nif (true)\r\n  module.exports = Module;\r\nelse {}\r\n\n\n//# sourceURL=webpack:///./src/RocketSim.js?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!********************************!*\
  !*** external "require('fs')" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require('fs');

/***/ }),

/***/ "path":
/*!**********************************!*\
  !*** external "require('path')" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require('path');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && !queue.d) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = 1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;